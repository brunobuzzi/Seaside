WACallback subclass: #JSAjaxCallback	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!WAObject subclass: #JSObject	instanceVariableNames: 'decoration renderContext rendererClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!JSObject subclass: #JSLogger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!JSObject subclass: #JSJoin	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!JSObject subclass: #JSScript	instanceVariableNames: 'statements'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!WAObject subclass: #JSDecoration	instanceVariableNames: 'owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSIfThenElse	instanceVariableNames: 'trueStatement falseStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSCreate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSNegation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSAssignment	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSMember	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSTimed	instanceVariableNames: 'duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSMember subclass: #JSAssign	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSDecoration subclass: #JSStatement	instanceVariableNames: 'statement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSStatement subclass: #JSConcatenation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSMember subclass: #JSAccess	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSStatement subclass: #JSCondition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSStatement subclass: #JSBinary	instanceVariableNames: 'operator'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSObject subclass: #JSJson	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!JSDecoration subclass: #JSCall	instanceVariableNames: 'name arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSMember subclass: #JSProperty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSTimed subclass: #JSTimeout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!WACallback subclass: #JSPassenger	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!JSDecoration subclass: #JSApply	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSAssign subclass: #JSAssignLocal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSTimed subclass: #JSInterval	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSObject subclass: #JSStream	instanceVariableNames: 'stream'	classVariableNames: 'Arguments JavascriptCharacters This'	poolDictionaries: ''	category: 'Javascript-Core'!JSMember subclass: #JSAlias	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSCondition subclass: #JSConditionElse	instanceVariableNames: 'elseStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!JSScript subclass: #JSFunction	instanceVariableNames: 'return arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.242569 am'!!Stream methodsFor: '*javascript-core' stamp: 'lr 4/11/2006 19:45'!javascript: anObject	anObject javascriptOn: self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.24394 am'!!Object methodsFor: '*javascript-core' stamp: 'lr 4/20/2006 21:10'!javascriptOn: aStream	self printOn: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.244519 am'!!Object methodsFor: '*javascript-core' stamp: 'lr 12/4/2008 22:30'!isJavascript	^ false! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.244847 am'!!Object methodsFor: '*javascript-core' stamp: 'lr 1/4/2007 17:20'!asFunction	^ self asFunction: #()! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.245058 am'!!Object methodsFor: '*javascript-core' stamp: 'lr 4/11/2006 19:49'!asJavascript	^ String streamContents: [ :stream | self javascriptOn: stream ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.245195 am'!!Object methodsFor: '*javascript-core' stamp: 'lr 10/14/2008 00:37'!asFunction: aCollection	^ JSFunction new add: self; arguments: aCollection! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.246356 am'!!WARenderer methodsFor: '*javascript-core' stamp: 'jf 7/19/2009 18:44'!javascript	^ (JSScript context: self context)		rendererClass: self species;		yourself! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.24648 am'!!WARenderer methodsFor: '*javascript-core' stamp: 'jf 7/19/2009 18:44'!logger	^ (JSLogger context: self context)		rendererClass: self species;		yourself! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.246628 am'!!WAUrl methodsFor: '*javascript-core' stamp: 'lr 10/13/2008 21:06'!javascriptOn: aStream 	aStream javascript: self printString! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.246815 am'!!GRSmallDictionary methodsFor: '*javascript-core' stamp: 'lr 2/12/2009 09:44'!javascriptOn: aStream	JSStream encodeDictionary: self on: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.246944 am'!!UndefinedObject methodsFor: '*javascript-core' stamp: 'lr 4/11/2006 19:44'!javascriptOn: aStream	aStream nextPutAll: 'null'! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247073 am'!!WATagBrush methodsFor: '*javascript-core' stamp: 'lr 1/23/2009 07:58'!passenger: anObject	"Assign a passenger object to the receiver. This is used to keep a mapping between DOM elements and Smalltalk objects. Note, that to we are required to assign a numeric id to the reciever in order to keep the mapping between DOM element and Smalltalk object."	canvas callbacks registerPassenger: anObject named: self ensureId! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247205 am'!!WATagBrush methodsFor: '*javascript-core' stamp: 'lr 12/24/2009 10:31'!script: anObject	"Attach a JavaScript object to the receiver. The argument automatically knows the ID of the DOM element it should operate on and will be evaluated when the page complete loading."	(anObject isNil) 		ifTrue: [ ^ self ].	(anObject respondsTo: #id:)		ifTrue: [ anObject id: self ensureId ].	canvas document addLoadScript: anObject! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247329 am'!!String methodsFor: '*javascript-core' stamp: 'lr 2/12/2009 09:45'!javascriptOn: aStream	JSStream encodeString: self on: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247463 am'!!String methodsFor: '*javascript-core' stamp: 'lr 10/14/2008 00:37'!asFunction: aCollection	^ (JSStream on: self) asFunction: aCollection! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247578 am'!!Dictionary methodsFor: '*javascript-core' stamp: 'lr 2/12/2009 09:44'!javascriptOn: aStream	JSStream encodeDictionary: self on: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.24769 am'!!DateAndTime methodsFor: '*javascript-core' stamp: 'lr 3/13/2007 09:05'!javascriptMonthIndex	^ self monthIndex - 1! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247829 am'!!DateAndTime methodsFor: '*javascript-core' stamp: 'lr 12/6/2009 19:48'!javascriptOn: aStream	aStream nextPutAll: 'new Date('.	#( year javascriptMonthIndex dayOfMonth hour minute second )		do: [ :each | aStream javascript: (self perform: each) ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $)! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.247942 am'!!WACallbackRegistry methodsFor: '*javascript-core' stamp: 'lr 10/21/2008 16:39'!passengerAt: aString	^ self passengerAt: aString ifAbsent: [ nil ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248052 am'!!WACallbackRegistry methodsFor: '*javascript-core' stamp: 'lr 12/28/2008 16:33'!passengerAt: aString ifAbsent: aBlock	| passenger |	passenger := callbacks at: aString ifAbsent: [ ^ aBlock value ].	passenger isPassenger ifFalse: [ ^ aBlock value ].	^ passenger object! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248159 am'!!WACallbackRegistry methodsFor: '*javascript-core' stamp: 'lr 1/23/2009 08:01'!registerPassenger: anObject named: aString	| callback |	callback := JSPassenger new.	callback setKey: aString callbacks: callbacks; setObject: anObject.	callbacks at: (callback convertKey: aString) put: callback.	^ aString! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248267 am'!!Character methodsFor: '*javascript-core' stamp: 'lr 7/12/2006 12:09'!javascriptOn: aStream	(String with: self) javascriptOn: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248382 am'!!Date methodsFor: '*javascript-core' stamp: 'lr 3/13/2007 09:04'!javascriptMonthIndex	^ self monthIndex - 1! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248505 am'!!Date methodsFor: '*javascript-core' stamp: 'lr 12/6/2009 19:48'!javascriptOn: aStream	aStream nextPutAll: 'new Date('.	#( year javascriptMonthIndex dayOfMonth )		do: [ :each | aStream javascript: (self perform: each) ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $)! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248627 am'!!WACallback methodsFor: '*javascript-core' stamp: 'lr 10/21/2008 16:16'!isPassenger	^ false! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.24873 am'!!Collection methodsFor: '*javascript-core' stamp: 'lr 2/12/2009 09:43'!javascriptOn: aStream	JSStream encodeCollection: self on: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.24884 am'!!Duration methodsFor: '*javascript-core' stamp: 'jf 2/6/2010 00:13'!javascriptOn: aStream	aStream javascript: self asMilliseconds! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 13 April 2018 at 11:29:10.248949 am'!!GRPackage class methodsFor: '*javascript-core' stamp: 'lr 2/17/2010 15:11'!javascriptCore	^ self new		name: 'Javascript-Core';		description: 'Javascript integration in Seaside. Provides a basic functionality to generate Javascript from Smalltalk.';		addDependency: 'Seaside-Core';		addDependency: 'Seaside-Canvas';		url: #seasideUrl;		yourself! !WAObject subclass: #JSDecoration	instanceVariableNames: 'owner'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSDecoration commentStamp: 'lr 4/28/2008 09:47' prior: 0!I decorate JavaScript objects.!!JSDecoration methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	self owner javascriptContentOn: aStream! !!JSDecoration methodsFor: 'accessing' stamp: 'jf 7/19/2009 15:00'!renderContext	^ owner renderContext! !!JSDecoration methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:09'!owner	^ owner! !!JSDecoration methodsFor: 'initialization' stamp: 'lr 11/17/2008 20:15'!setOwner: anObject	owner := anObject! !!JSDecoration methodsFor: 'testing' stamp: 'lr 12/4/2008 22:31'!isJavascript	^ true! !JSDecoration subclass: #JSApply	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSApply commentStamp: 'lr 4/28/2008 09:47' prior: 0!I apply a JavaScript function and provide arguments.!!JSApply methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:49'!arguments	^ arguments! !!JSApply methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:49'!arguments: aCollection	arguments := aCollection! !!JSApply methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	JSStream encodeArguments: self arguments on: aStream! !JSDecoration subclass: #JSAssignment	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSAssignment commentStamp: 'lr 4/28/2008 09:48' prior: 0!I represent an assignment ot the decorated object.!!JSAssignment methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream		nextPutAll: '=';		javascript: self object! !!JSAssignment methodsFor: 'accessing' stamp: 'lr 7/4/2007 07:43'!object	^ object! !!JSAssignment methodsFor: 'accessing' stamp: 'lr 7/4/2007 07:44'!object: anObject	object := anObject! !JSDecoration subclass: #JSCall	instanceVariableNames: 'name arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSCall commentStamp: 'pmm 2/18/2011 22:52' prior: 0!I represent a function call or method invocation to the decorated object.!!JSCall methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	(self name isNil or: [ self name isEmpty ]) ifFalse:			[ aStream				nextPut: $.;				nextPutAll: self name ].	JSStream encodeArguments: self arguments on: aStream! !!JSCall methodsFor: 'accessing' stamp: 'lr 4/7/2009 16:48'!name	^ name! !!JSCall methodsFor: 'accessing' stamp: 'lr 4/7/2009 16:48'!name: aString 	name := aString! !!JSCall methodsFor: 'accessing' stamp: 'lr 4/7/2009 16:48'!arguments	^ arguments! !!JSCall methodsFor: 'accessing' stamp: 'lr 4/7/2009 16:48'!arguments: anArray 	arguments := anArray! !JSDecoration subclass: #JSCreate	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSCreate commentStamp: 'lr 4/28/2008 09:48' prior: 0!I instantiate the decorated object.!!JSCreate methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'new '.	super javascriptContentOn: aStream! !JSDecoration subclass: #JSIfThenElse	instanceVariableNames: 'trueStatement falseStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSIfThenElse commentStamp: 'lr 4/28/2008 09:50' prior: 0!I execute different code snippets depending if the receiver is true (defined) or false (null).!!JSIfThenElse methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:16'!trueStatement	^ trueStatement! !!JSIfThenElse methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:16'!falseStatement: anObject	falseStatement := anObject! !!JSIfThenElse methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:16'!falseStatement	^ falseStatement! !!JSIfThenElse methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:16'!trueStatement: anObject	trueStatement := anObject! !!JSIfThenElse methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPut: $(.	super javascriptContentOn: aStream.	aStream nextPut: $?.	aStream javascript: self trueStatement.	aStream nextPut: $:.	aStream javascript: self falseStatement.	aStream nextPut: $)! !JSDecoration subclass: #JSMember	instanceVariableNames: 'name'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSMember methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:46'!name	^ name! !!JSMember methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:46'!name: aString	name := aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSMember class	instanceVariableNames: ''!!JSMember class methodsFor: 'instance creation' stamp: 'lr 10/13/2008 21:42'!named: anObject	^ self new name: anObject! !JSMember subclass: #JSAccess	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSAccess commentStamp: 'lr 4/28/2008 09:51' prior: 0!I access a member of the decorated object.!!JSAccess methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream		nextPut: $.;		nextPutAll: self name! !JSMember subclass: #JSAlias	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSAlias commentStamp: 'lr 4/28/2008 09:51' prior: 0!I alias the decorated object with a name.!!JSAlias methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: self name! !JSMember subclass: #JSAssign	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSAssign commentStamp: 'lr 4/28/2008 09:51' prior: 0!I assign the decorated object to a global variable.!!JSAssign methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream		nextPutAll: self name;		nextPut: $=.	super javascriptContentOn: aStream! !JSAssign subclass: #JSAssignLocal	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSAssignLocal commentStamp: 'lr 4/28/2008 09:52' prior: 0!I assign the decorated object to a local variable.!!JSAssignLocal methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'var '.	super javascriptContentOn: aStream! !JSDecoration subclass: #JSNegation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSNegation commentStamp: 'lr 4/28/2008 09:52' prior: 0!I negate the decorated object and yield a boolean value.!!JSNegation methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPut: $!!.	super javascriptContentOn: aStream! !JSMember subclass: #JSProperty	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSProperty commentStamp: 'pmm 2/18/2011 22:52' prior: 0!I access a property of the decorated object.!!JSProperty methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream		nextPut: $[;		javascript: self name;		nextPut: $]! !JSDecoration subclass: #JSStatement	instanceVariableNames: 'statement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSStatement methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:14'!statement	^ statement! !!JSStatement methodsFor: 'accessing' stamp: 'lr 5/9/2006 20:14'!statement: anObject	statement := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSStatement class	instanceVariableNames: ''!!JSStatement class methodsFor: 'instance creation' stamp: 'lr 5/9/2006 20:19'!on: anObject	^ self new statement: anObject! !JSStatement subclass: #JSBinary	instanceVariableNames: 'operator'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSBinary commentStamp: 'lr 4/28/2008 09:54' prior: 0!I join the decorated object with a binary operator.!!JSBinary methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream		nextPutAll: self operator;		javascript: self statement! !!JSBinary methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:22'!operator	^ operator! !!JSBinary methodsFor: 'accessing' stamp: 'lr 7/10/2007 10:22'!operator: aString	operator := aString! !JSStatement subclass: #JSConcatenation	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSConcatenation commentStamp: 'lr 12/31/2009 23:54' prior: 0!I represent a sequence (or concatenation) of a decorated object and another object.!!JSConcatenation methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream		nextPut: $;;		javascript: self statement! !JSStatement subclass: #JSCondition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSCondition commentStamp: 'lr 4/28/2008 09:53' prior: 0!I wrap the decorated object into a conditional statement.!!JSCondition methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream		nextPutAll: 'if(';		javascript: self statement;		nextPutAll: '){'.	super javascriptContentOn: aStream.	aStream nextPut: $}! !JSCondition subclass: #JSConditionElse	instanceVariableNames: 'elseStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSConditionElse methodsFor: 'accessing' stamp: 'EstebanMaringolo 9/22/2014 17:04'!elseStatement	^ elseStatement! !!JSConditionElse methodsFor: 'accessing' stamp: 'EstebanMaringolo 9/22/2014 17:04'!elseStatement: anObject	elseStatement := anObject! !!JSConditionElse methodsFor: 'accessing' stamp: 'JohanBrichau 10/2/2014 21:18'!javascriptContentOn: aStream	super javascriptContentOn: aStream.	aStream 		nextPutAll: 'else{';		javascript: self elseStatement.	aStream nextPut: $}! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSConditionElse class	instanceVariableNames: ''!!JSConditionElse class methodsFor: 'instance creation' stamp: 'pmm 7/16/2015 15:57'!on: statement else: elseStatement	^ (super on: statement)		elseStatement: elseStatement;		yourself! !JSDecoration subclass: #JSTimed	instanceVariableNames: 'duration'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSTimed methodsFor: 'accessing' stamp: 'lr 10/13/2008 21:39'!duration: aDuration	duration := aDuration! !!JSTimed methodsFor: 'accessing' stamp: 'lr 10/13/2008 21:39'!duration	^ duration! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSTimed class	instanceVariableNames: ''!!JSTimed class methodsFor: 'instance creation' stamp: 'lr 10/13/2008 21:45'!duration: aDuration	^ self new duration: aDuration! !JSTimed subclass: #JSInterval	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSInterval commentStamp: 'lr 10/13/2008 21:46' prior: 0!I periodically execute the decorated object.!!JSInterval methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'setInterval(function(){'.	super javascriptContentOn: aStream.	aStream		nextPutAll: '},';		javascript: self duration;		nextPut: $)! !JSTimed subclass: #JSTimeout	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core-Decorations'!!JSTimeout commentStamp: 'lr 4/28/2008 09:54' prior: 0!I evaluate the decorated object after a timeout.!!JSTimeout methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'setTimeout(function(){'.	super javascriptContentOn: aStream.	aStream		nextPutAll: '},';		javascript: self duration;		nextPut: $)! !WACallback subclass: #JSAjaxCallback	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSAjaxCallback methodsFor: 'accessing' stamp: 'lr 12/6/2008 20:54'!block: aZeroOrOneArgBlock	block := aZeroOrOneArgBlock isNil		ifFalse: [ aZeroOrOneArgBlock fixCallbackTemps ]! !!JSAjaxCallback methodsFor: 'accessing' stamp: 'lr 12/28/2008 14:49'!priority	^ 5! !!JSAjaxCallback methodsFor: 'evaluation' stamp: 'lr 5/20/2009 19:58'!evaluateWithArgument: anObject	block isNil		ifFalse: [ block valueWithPossibleArguments: (Array with: anObject) ].	self requestContext		respond: [ :response | response doNotCache ]! !WAObject subclass: #JSObject	instanceVariableNames: 'decoration renderContext rendererClass'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSObject commentStamp: 'lr 12/31/2009 23:50' prior: 0!I represent the abstract root of all JavaScript objects in the Smalltalk world. My subclasses provide accessors and action methods to configure instances of myself and implement the method #javascriptContentOn: to emit valid JavaScript code for my presentation.Instance Variables	decoration:			<JSObject|JSDecoration>	renderContext:		<WARenderContext>	rendererClass:		<WARenderer>!!JSObject methodsFor: 'printing' stamp: 'lr 12/31/2009 23:48'!javascriptOn: aStream	"Generate the JavaScript code from the receiver by dispatching to the outermost surrounding decoration. Do not override this method, instead override #javascriptContentOn:."	self decoration javascriptContentOn: aStream! !!JSObject methodsFor: 'printing' stamp: 'lr 12/24/2009 10:34'!greaseString	^ String streamContents: [ :stream | stream javascript: self ]! !!JSObject methodsFor: 'printing' stamp: 'lr 12/31/2009 23:48'!javascriptContentOn: aStream	"Generate the JavaScript string of the receiver. Override this method in subclasses to define custom JavaScript code. Note, if you run into this method, you likely use old Seaside code need to rename #printContentOn: to #javascriptContentOn:."		self subclassResponsibility! !!JSObject methodsFor: 'printing' stamp: 'lr 12/24/2009 10:35'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ('; javascript: self; nextPut: $)! !!JSObject methodsFor: 'testing' stamp: 'lr 12/4/2008 22:30'!isJavascript	^ true! !!JSObject methodsFor: 'utilities' stamp: 'lr 10/14/2008 21:48'!render: aRenderable	"Render aRenderable and answer the resulting string."		^ String streamContents: [ :stream | self render: aRenderable on: stream ]! !!JSObject methodsFor: 'utilities' stamp: 'lr 2/22/2010 22:28'!render: aRenderable on: aStream	"Render aRenderable on aStream."		| document |	document := WAHtmlDocument		on: aStream		codec: self requestContext codec.	self renderContext document: document during: [		(self rendererClass context: self renderContext)			render: aRenderable; flush ].	document scriptGenerator closeOn: document! !!JSObject methodsFor: 'utilities' stamp: 'lr 2/22/2010 22:12'!script: aBlock on: aStream	"Evaluate aBlock and pass in a script object that is subsequently written to aStream."	| script document |	document := WAHtmlDocument		on: aStream		codec: self requestContext codec.	self renderContext document: document during: [ 		script := (JSScript context: self renderContext)			rendererClass: self rendererClass;			yourself.		aBlock value: script.		script addAll: document loadScripts ].	script javascriptOn: aStream! !!JSObject methodsFor: 'utilities' stamp: 'lr 10/14/2008 21:48'!script: aBlock	"Evaluate aBlock and answer the string of the generated script."		^ String streamContents: [ :stream | self script: aBlock on: stream ]! !!JSObject methodsFor: 'accessing' stamp: 'pmm 8/19/2014 10:14'!renderContext	"Answer the current WARenderContext."	^ renderContext! !!JSObject methodsFor: 'accessing' stamp: 'jf 7/19/2009 18:23'!rendererClass	"Answer the class that should be used when rendering objects."	^ rendererClass ifNil: [ rendererClass := WARenderer default ]! !!JSObject methodsFor: 'accessing' stamp: 'jf 7/19/2009 17:21'!rendererClass: aRendererClass	"Specify the class that should be used when rendering objects."	rendererClass := aRendererClass! !!JSObject methodsFor: 'accessing' stamp: 'lr 10/13/2008 21:14'!decoration	"Answer the top-level decoration in the receivers decoration stack."	^ decoration! !!JSObject methodsFor: 'decorations' stamp: 'lr 4/24/2009 20:22'!call: aString	"Call the method named aString."	self call: aString withArguments: #()! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:43'!assignTo: aString 	"Assign the receiver to a global variable aString."		self addDecoration: (JSAssign named: aString)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:44'!interval: aDuration	"Execute the receiver every aDuration."	self addDecoration: (JSInterval duration: aDuration)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:40'!assign: anObject 	"Assign anObject to the receiver."		self addDecoration: (JSAssignment new object: anObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 4/24/2009 20:22'!call: aString with: anObject1 with: anObject2 with: anObject3	"Call the method named aString with anObject1 and anObject2 and anObject3 as its arguments."	self call: aString withArguments: (Array with: anObject1 with: anObject2 with: anObject3)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:44'!& anObject 	"Combine the receiver and anObject with a logical AND."		self addDecoration: (JSBinary new operator: '&&'; statement: anObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:40'!apply: aCollection 	"Apply aCollection of arguments."		self addDecoration: (JSApply new arguments: aCollection)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:42'!alias: aString 	"Uses aString as an alias for the receiver."		self addDecoration: (JSAlias named: aString)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:41'!create	"Instantiate the receiver."		self addDecoration: JSCreate new! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:44'!| anObject 	"Combine the receiver and anObject with a logical OR."		self addDecoration: (JSBinary new operator: '||'; statement: anObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:44'!timeout: aDuration 	"Evaluates the receiver after aDuration."		self addDecoration: (JSTimeout duration: aDuration)! !!JSObject methodsFor: 'decorations' stamp: 'EstebanMaringolo 9/22/2014 17:11'!condition: anObject  else: otherObject	"Treat anObject as a condition to the execution of the receiver."		self addDecoration: (JSConditionElse on: anObject else: otherObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:41'!condition: anObject 	"Treat anObject as a condition to the execution of the receiver."		self addDecoration: (JSCondition on: anObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:42'!access: aString 	"Access the member aString."		self addDecoration: (JSAccess named: aString)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:43'!assignLocalTo: aString 	"Assign the receiver to a local variable aString."		self addDecoration: (JSAssignLocal named: aString)! !!JSObject methodsFor: 'decorations' stamp: 'lr 4/24/2009 20:22'!call: aString with: anObject	"Call the method named aString with anObject as its argument."	self call: aString withArguments: (Array with: anObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 4/24/2009 20:22'!call: aString with: anObject1 with: anObject2	"Call the method named aString with anObject1 and anObject2 as its arguments."	self call: aString withArguments: (Array with: anObject1 with: anObject2)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:41'!not	"Negate the receiver logically."		self addDecoration: JSNegation new! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:41'!then: anObject else: anotherObject 	"Evaluates anObject if the receiver treated as a boolean evaluates to true, otherwise evaluate anotherObject."		self addDecoration: (JSIfThenElse new		trueStatement: anObject;		falseStatement: anotherObject)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:16'!then: anObject	"Evaluates anObject if the receiver treated as a boolean evaluates to true."	self then: anObject else: nil! !!JSObject methodsFor: 'decorations' stamp: 'lr 4/24/2009 20:22'!call: aString withArguments: anArray	"Call the method named aString with anArray as arguments."	self addDecoration: (JSCall new 		name: aString;		arguments: anArray;		yourself)! !!JSObject methodsFor: 'decorations' stamp: 'lr 10/13/2008 21:43'!property: aString 	"Treat anObject as a condition to the execution of the receiver."		self addDecoration: (JSProperty named: aString)! !!JSObject methodsFor: 'adding' stamp: 'lr 11/17/2008 20:15'!addDecoration: aDecoration	"Add a new decoration to the receiver."	aDecoration setOwner: decoration.	decoration := aDecoration! !!JSObject methodsFor: 'initialization' stamp: 'lr 11/11/2008 22:57'!initialize	super initialize.	decoration := self! !!JSObject methodsFor: 'initialization' stamp: 'jf 7/19/2009 14:06'!setContext: aRenderContext	renderContext := aRenderContext! !!JSObject methodsFor: 'convenience' stamp: 'lr 10/14/2008 12:22'!return: anObject 	"Return anObject after evaluating the receiver."		self , (JSStream new		nextPutAll: 'return ';		javascript: anObject)! !!JSObject methodsFor: 'convenience' stamp: 'lr 10/14/2008 12:19'!confirm: anObject 	"Show a confirmation with the message anObject before evaluating the receiver."		self condition: (JSStream new		nextPutAll: 'confirm';		argument: anObject)! !!JSObject methodsFor: 'convenience' stamp: 'lr 12/31/2009 23:44'!, anObject 	"Concatenate the receiver with anObject."	self addDecoration: (JSConcatenation on: anObject)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSObject class	instanceVariableNames: ''!!JSObject class methodsFor: 'instance creation' stamp: 'jf 7/19/2009 14:07'!context: aRenderContext	^ self new setContext: aRenderContext; yourself! !JSObject subclass: #JSJoin	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSJoin commentStamp: 'lr 4/28/2008 09:46' prior: 0!I join a collection of JavaScript statements with the given string.!!JSJoin methodsFor: 'encoding' stamp: 'lr 7/14/2010 12:48'!encodeEmptyOn: aDocument	aDocument nextPutAll: '""'! !!JSJoin methodsFor: 'encoding' stamp: 'lr 7/14/2010 13:24'!encodeElement: anObject on: aDocument	"We assume that the element is already URL encoded if this is not an association."	(anObject isKindOf: Association)		ifTrue: [			aDocument nextPut: $".			aDocument urlEncoder				nextPutAll: anObject key greaseString.			anObject value isNil 				ifTrue: [ aDocument nextPut: $" ]				ifFalse: [					aDocument nextPut: $=.					(anObject value isString or: [ anObject value isCharacter ])						ifTrue: [							aDocument urlEncoder 								nextPutAll: anObject value greaseString.							aDocument nextPut: $" ]						ifFalse: [							aDocument nextPutAll: '"+encodeURIComponent('.							aDocument stream javascript: anObject value.							aDocument nextPut: $) ] ] ]		ifFalse: [ aDocument stream javascript: anObject ]! !!JSJoin methodsFor: 'encoding' stamp: 'lr 7/14/2010 12:48'!encodeOn: aDocument	self collection isEmpty		ifTrue: [ ^ self encodeEmptyOn: aDocument ].	self collection size = 1		ifTrue: [ ^ self encodeElement: self collection first on: aDocument ].	aDocument nextPut: $[.	self collection		do: [ :each | self encodeElement: each on: aDocument ]		separatedBy: [ aDocument nextPut: $, ].	aDocument nextPutAll: '].join("&")'! !!JSJoin methodsFor: 'printing' stamp: 'lr 7/14/2010 13:11'!javascriptContentOn: aStream	| document codec |	codec := [ self requestContext codec ] 		on: WARequestContextNotFound		do: [ :e | GRNullCodec new ].	document := WAUnescapedDocument 		on: aStream		codec: codec.	self encodeOn: document! !!JSJoin methodsFor: 'initialization' stamp: 'jf 3/13/2009 17:59'!initializeOn: aCollection	self initialize.	collection := aCollection! !!JSJoin methodsFor: 'accessing' stamp: 'avi 9/27/2005 23:40'!collection	^ collection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSJoin class	instanceVariableNames: ''!!JSJoin class methodsFor: 'instance creation' stamp: 'lr 10/16/2008 19:19'!new	^ self on: OrderedCollection new! !!JSJoin class methodsFor: 'instance creation' stamp: 'lr 10/16/2008 19:19'!on: aCollection	^ self basicNew initializeOn: aCollection! !JSObject subclass: #JSJson	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSJson commentStamp: 'pmm 2/1/2014 13:35' prior: 0!I represent the JSON object (www.json.org) that is supported by most modern web browsers. For older browsers I require WAJsonDeploymentLibrary or WAJsonDevelopmentLibrary to be included.!!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:44'!parse: aString	"This method parses a JSON text to produce an object or array."	self call: 'parse' with: aString! !!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:42'!stringify: anObject replacer: aReplacer	"Serialize anObject as a JSON string. aReplacer is an optional parameter that determines how object values are stringified for objects. It can be a function or an array of strings."	self call: 'stringify' with: anObject with: aReplacer! !!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:42'!stringify: anObject space: aSpace	"Serialize anObject as a JSON string. aSpace is an optional parameter that specifies the indentation of nested structures. If it is omitted, the text will be packed without extra whitespace."	self call: 'stringify' with: anObject with: aSpace! !!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:42'!stringify: anObject replacer: aReplacer space: aSpace	"Serialize anObject as a JSON string. aReplacer is an optional parameter that determines how object values are stringified for objects. It can be a function or an array of strings. aSpace is an optional parameter that specifies the indentation of nested structures. If it is omitted, the text will be packed without extra whitespace."	self call: 'stringify' with: anObject with: aReplacer with: aSpace! !!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:48'!parse: aString reviver: aFunction 	"This method parses a JSON text to produce an object or array. The optional reviver parameter is a function that can filter and transform the results. It receives each of the keys and values, and its return value is used instead of the original value. If it returns what it received, then the structure is not modified. If it returns undefined then the member is deleted."	self call: 'parse' with: aString with: aFunction asFunction! !!JSJson methodsFor: 'accessing' stamp: 'lr 9/22/2009 10:39'!stringify: anObject	"Serialize anObject as a JSON string."	self call: 'stringify' with: anObject! !!JSJson methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'JSON'! !JSObject subclass: #JSLogger	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSLogger commentStamp: 'lr 11/28/2006 10:40' prior: 0!I am a logger class to be used together with FireBug. I have nothing to do with Scriptaculous directly, but I nicely fit in here as everybody should be using FireBug for Script debugging anyway.!!JSLogger methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'console'! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assert: anObject 	self 		call: 'assert'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertTrue: anObject 	self 		call: 'assertTrue'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertNotUndefined: anObject 	self 		call: 'assertNotUndefined'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:13'!assert: anObject equals: anotherObject 	self 		call: 'assertEquals'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:12'!assert: anObject notEquals: anotherObject 	self 		call: 'assertNotEquals'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertNotNull: anObject 	self 		call: 'assertNotNull'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertNull: anObject 	self 		call: 'assertNull'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:13'!assert: anObject notLess: anotherObject 	self 		call: 'assertNotLess'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertUndefined: anObject 	self 		call: 'assertUndefined'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:11'!assert: anObject greater: anotherObject 	self 		call: 'assertGreater'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:13'!assert: anObject notGreater: anotherObject 	self 		call: 'assertNotGreater'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:10'!assertFalse: anObject 	self 		call: 'assertFalse'		with: anObject! !!JSLogger methodsFor: 'assertions' stamp: 'lr 10/14/2008 09:11'!assert: anObject less: anotherObject 	self 		call: 'assertLess'		with: anObject		with: anotherObject! !!JSLogger methodsFor: 'logging' stamp: 'lr 10/14/2008 09:10'!log: anObject 	self 		call: 'log'		with: anObject! !!JSLogger methodsFor: 'logging' stamp: 'lr 10/14/2008 09:10'!log: anObject format: anArray 	self 		call: 'log'		withArguments: (Array with: anObject) , anArray! !!JSLogger methodsFor: 'messages' stamp: 'lr 10/14/2008 09:10'!warn: anObject 	self 		call: 'warn'		with: anObject! !!JSLogger methodsFor: 'messages' stamp: 'lr 10/14/2008 09:10'!error: anObject 	self 		call: 'error'		with: anObject! !!JSLogger methodsFor: 'messages' stamp: 'lr 10/14/2008 09:10'!debug: anObject 	self 		call: 'debug'		with: anObject! !!JSLogger methodsFor: 'messages' stamp: 'lr 10/14/2008 09:10'!info: anObject 	self 		call: 'info'		with: anObject! !WACallback subclass: #JSPassenger	instanceVariableNames: 'object'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSPassenger methodsFor: 'testing' stamp: 'lr 10/21/2008 16:15'!isPassenger	^ true! !!JSPassenger methodsFor: 'testing' stamp: 'lr 2/15/2009 16:56'!isEnabledFor: aRequestContext	^ false! !!JSPassenger methodsFor: 'evaluation' stamp: 'lr 10/21/2008 16:07'!evaluateWithArgument: anObject	self shouldNotImplement! !!JSPassenger methodsFor: 'accessing' stamp: 'lr 10/21/2008 16:08'!object	^ object! !!JSPassenger methodsFor: 'initialization' stamp: 'lr 10/21/2008 16:09'!setObject: anObject	object := anObject! !JSObject subclass: #JSScript	instanceVariableNames: 'statements'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSScript commentStamp: 'lr 4/28/2008 09:41' prior: 0!I represent a sequence of JavaScript statements.!!JSScript methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	statements do: [ :each | aStream javascript: each ] separatedBy: [ aStream nextPut: $; ]! !!JSScript methodsFor: 'adding' stamp: 'lr 10/19/2008 19:10'!<< anObject	^ self add: anObject! !!JSScript methodsFor: 'adding' stamp: 'lr 12/3/2008 19:11'!addAll: aCollection	^ statements addAll: aCollection! !!JSScript methodsFor: 'adding' stamp: 'lr 8/29/2006 08:36'!, anObject	self add: anObject! !!JSScript methodsFor: 'adding' stamp: 'lr 8/4/2006 08:59'!add: anObject	^ statements add: anObject! !!JSScript methodsFor: 'convenience' stamp: 'jf 2/15/2010 02:11'!callback: aBlock	self goto: (self renderContext actionUrl		withField: (self renderContext callbacks store: (WAActionCallback on: aBlock)))! !!JSScript methodsFor: 'convenience' stamp: 'lr 9/22/2009 10:52'!logger	^ self add: ((JSLogger context: self renderContext)		rendererClass: self rendererClass;		yourself)! !!JSScript methodsFor: 'convenience' stamp: 'lr 10/13/2008 21:34'!alert: anObject 	self add: (JSStream new		nextPutAll: 'alert';		argument: anObject;		yourself)! !!JSScript methodsFor: 'convenience' stamp: 'lr 10/28/2009 20:57'!javascript	^ (JSScript context: self renderContext)		rendererClass: self rendererClass;		yourself! !!JSScript methodsFor: 'convenience' stamp: 'jf 7/19/2009 13:57'!refresh	self goto: self renderContext actionUrl! !!JSScript methodsFor: 'convenience' stamp: 'lr 9/8/2009 12:50'!goto: aUrl 	self add: (JSStream new		nextPutAll: 'window.location=';		javascript: aUrl)! !!JSScript methodsFor: 'initialization' stamp: 'lr 5/10/2006 19:47'!initialize	super initialize.	statements := OrderedCollection new! !JSScript subclass: #JSFunction	instanceVariableNames: 'return arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Javascript-Core'!!JSFunction commentStamp: 'lr 4/28/2008 09:40' prior: 0!I represent an anonymous JavaScript function.!!JSFunction methodsFor: 'accessing' stamp: 'lr 5/15/2006 11:04'!return: aBoolean	return := aBoolean! !!JSFunction methodsFor: 'accessing' stamp: 'lr 1/4/2007 15:57'!argument	^ arguments! !!JSFunction methodsFor: 'accessing' stamp: 'lr 1/4/2007 15:55'!arguments: aCollection	arguments := aCollection! !!JSFunction methodsFor: 'accessing' stamp: 'lr 1/4/2007 15:55'!arguments	^ arguments! !!JSFunction methodsFor: 'accessing' stamp: 'lr 5/15/2006 11:04'!return	^ return ifNil: [ false ]! !!JSFunction methodsFor: 'converting' stamp: 'lr 5/17/2006 11:27'!asFunction	^ self! !!JSFunction methodsFor: 'converting' stamp: 'lr 1/4/2007 17:22'!asFunction: aCollection	self arguments: aCollection! !!JSFunction methodsFor: 'initialization' stamp: 'lr 1/4/2007 15:59'!initialize	super initialize.	arguments := #()! !!JSFunction methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: 'function('.	self arguments do: [ :each | aStream nextPutAll: each ] separatedBy: [ aStream nextPut: $, ].	aStream nextPutAll: '){'.	statements isEmpty ifFalse:			[ statements allButLast do:					[ :each | 					aStream						javascript: each;						nextPut: $; ].			self return ifTrue: [ aStream nextPutAll: 'return ' ].			aStream javascript: statements last ].	aStream nextPut: $}! !JSObject subclass: #JSStream	instanceVariableNames: 'stream'	classVariableNames: 'Arguments JavascriptCharacters This'	poolDictionaries: ''	category: 'Javascript-Core'!!JSStream commentStamp: 'lr 4/28/2008 09:44' prior: 0!I represent a verbatim JavaScript string. I support streaming facilities to efficiently encode JavaScript input.!!JSStream methodsFor: 'accessing' stamp: 'lr 5/1/2006 17:06'!contents	^ self stream contents! !!JSStream methodsFor: 'accessing' stamp: 'lr 5/1/2006 17:06'!stream	^ stream! !!JSStream methodsFor: 'printing' stamp: 'lr 12/24/2009 10:16'!javascriptContentOn: aStream	aStream nextPutAll: self contents! !!JSStream methodsFor: 'copying' stamp: 'lr 5/10/2006 20:36'!copy	^ self class on: self contents! !!JSStream methodsFor: 'initialization' stamp: 'lr 2/4/2009 08:02'!initialize	super initialize.	stream := WriteStream on: String new! !!JSStream methodsFor: 'convenience' stamp: 'lr 2/12/2009 09:56'!argument: anObject	"Write a single argument anObject onto the receiving stream."	self arguments: (Array with: anObject)! !!JSStream methodsFor: 'convenience' stamp: 'lr 2/12/2009 09:57'!arguments: aCollection	"Write aCollection of arguments onto the stream."	self class encodeArguments: aCollection on: self! !!JSStream methodsFor: 'streaming' stamp: 'lr 2/2/2010 21:24'!json: anObject	self stream json: anObject! !!JSStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!nextPutAll: aString	self stream nextPutAll: aString! !!JSStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!javascript: anObject	self stream javascript: anObject! !!JSStream methodsFor: 'streaming' stamp: 'lr 5/1/2006 17:07'!nextPut: aCharacter	self stream nextPut: aCharacter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!JSStream class	instanceVariableNames: ''!!JSStream class methodsFor: 'encoding' stamp: 'lr 2/12/2009 09:44'!encodeDictionary: aDictionary on: aStream 	"Dictionary or hash-maps common structures in JavaScript, try to optimize their serialization."		| first |	first := true.	aStream nextPut: ${.	aDictionary keysAndValuesDo: [ :key :value |		first			ifTrue: [ first := false ]			ifFalse: [ aStream nextPut: $, ].		self encodeKey: key value: value on: aStream ].	aStream nextPut: $}! !!JSStream class methodsFor: 'encoding' stamp: 'pmm 8/19/2014 10:07'!encodeCollection: aCollection on: aStream	"Writes aCollection of elements to aStream enclosed in square brackets."		aStream nextPut: $[.	aCollection		do: [ :each | aStream javascript: each ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $]! !!JSStream class methodsFor: 'encoding' stamp: 'lr 2/12/2009 09:43'!encodeArguments: aCollection on: aStream 	"Writes aCollection of elements to aStream enclosed in round brakes and separated by a comma."		aStream nextPut: $(.	aCollection		do: [ :each | aStream javascript: each ]		separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $)! !!JSStream class methodsFor: 'encoding' stamp: 'pmm 5/7/2012 19:32'!encodeString: aString on: aStream 	"Strings have a complicated encoding in Javascript, try to optimize their serialization."			aStream nextPut: $".	1 to: aString size do: [ :index | 		| char value encoded |		char := aString at: index.		value := char greaseInteger.		value < JavascriptCharacters size 			ifFalse: [				"U+2028 and U+2029 have to be treaded as new lines"				value = 16r2028 "Line separator"					ifTrue: [ aStream nextPutAll: '\u2028' ]					ifFalse: [						value = 16r2029 "Paragraph separator"							ifTrue: [ aStream nextPutAll: '\u2029' ]							ifFalse: [ aStream nextPut: char ] ] ]			ifTrue: [				encoded := JavascriptCharacters at: value + 1.				"we use nil markers becausee #isNil is faster than #isString because it's not				actually sent"				encoded isNil 					ifTrue: [ aStream nextPut: char ]					ifFalse: [ aStream nextPutAll: encoded ] ] ].	aStream nextPut: $"! !!JSStream class methodsFor: 'encoding' stamp: 'lr 4/15/2010 20:21'!encodeKey: aKey value: aValue on: aStream 	"Key-value pairs are common structures in JavaScript."		aStream javascript: aKey greaseString; nextPut: $:; javascript: aValue! !!JSStream class methodsFor: 'instance creation' stamp: 'lr 10/14/2008 11:45'!this	^ This copy! !!JSStream class methodsFor: 'instance creation' stamp: 'lr 10/16/2008 21:49'!argument: anInteger	^ (Arguments at: anInteger + 1) copy! !!JSStream class methodsFor: 'instance creation' stamp: 'lr 10/16/2008 21:49'!argumentAt: anInteger	^ (Arguments at: anInteger) copy! !!JSStream class methodsFor: 'instance creation' stamp: 'lr 5/10/2006 20:36'!on: aString	^ self new nextPutAll: aString! !!JSStream class methodsFor: 'initialization' stamp: 'pmm 5/7/2012 19:24'!initialize	self initializeEncoding.	self initializeSnippets! !!JSStream class methodsFor: 'initialization' stamp: 'pmm 5/7/2012 19:27'!initializeEncoding	| printer escapes |	printer := GRNumberPrinter new.	printer base: 16; padding: $0; digits: 2.	JavascriptCharacters := Array new: 128.	0 to: 31 do: [ :index | 		JavascriptCharacters 			at: index + 1			put: '\x' , (printer print: index) ].	escapes := #( 0 '\0' 7 '\a' 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 34 '\"' 92 '\\' ).	1 to: escapes size - 1 by: 2 do: [ :index | 		JavascriptCharacters 			at: (escapes at: index) + 1			put: (escapes at: index + 1) ]! !!JSStream class methodsFor: 'initialization' stamp: 'lr 10/14/2008 11:36'!initializeSnippets	This := self on: 'this'.	Arguments := (0 to: 25)		collect: [ :each | self on: 'arguments[' , each printString , ']' ]! !JSStream initialize!