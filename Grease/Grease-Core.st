Error subclass: #GRError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!Notification subclass: #GRNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!GRNotification subclass: #GRDeprecatedApiNotification	instanceVariableNames: 'details'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!GRError subclass: #GRInvalidUtf8Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRError subclass: #GRInvalidArgumentCount	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!Object subclass: #GRObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!GRObject subclass: #GRDelayedSend	instanceVariableNames: 'receiver message'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!GRObject subclass: #GRPackage	instanceVariableNames: 'name description dependencies license url'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!GRObject subclass: #GRCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRSmallDictionary	instanceVariableNames: 'size keys values'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Collections'!GRSmallDictionary subclass: #GROrderedMultiMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Collections'!GRObject subclass: #GRDelegatingStream	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRDelayedSendMessage	instanceVariableNames: 'selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!GRDelayedSendMessage subclass: #GRBoundMessage	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!GRObject subclass: #GRPrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GRSequentialPrinter	instanceVariableNames: 'parts'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GRPluggablePrinter	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GROrdinalizePrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GRMappedPrinter	instanceVariableNames: 'next block'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GRSignPrinter	instanceVariableNames: 'negativePrinter positivePrinter'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRDelegatingStream subclass: #GRCountingStream	instanceVariableNames: 'count'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!GRDelegatingStream subclass: #GRCodecStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRCodecStream subclass: #GRNullCodecStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRCodec subclass: #GRNullCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRPlatform	instanceVariableNames: ''	classVariableNames: 'Current'	poolDictionaries: ''	category: 'Grease-Core'!GRPrinter subclass: #GRStringPrinter	instanceVariableNames: 'trim length pad character'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRPrinter subclass: #GRNumberPrinter	instanceVariableNames: 'characters base delimiter digits infinite nan padding accuracy precision separator'	classVariableNames: 'NumbersToCharactersLowercase NumbersToCharactersUppercase'	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRVersion	instanceVariableNames: 'major minor revision stageLabel stageNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!GRPrinter subclass: #GRUnitPrinter	instanceVariableNames: 'integerPrinter fractionPrinter units base'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRInflector	instanceVariableNames: ''	classVariableNames: 'InflectionRules Uninflected'	poolDictionaries: ''	category: 'Grease-Core-Text'!GRDelayedSendMessage subclass: #GRUnboundMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!GRError subclass: #GRUnsupportedEncodingError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRObject subclass: #GRCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRCodec commentStamp: 'lr 2/7/2009 09:55' prior: 0!A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.!!GRCodec methodsFor: 'convenience' stamp: 'pmm 8/26/2011 09:47'!decode: aString	| readStream writeStream |	readStream := self decoderFor: aString readStream.	writeStream := GRPlatform current writeCharacterStreamOn: (String new: aString size).	[ readStream atEnd ]		whileFalse: [ writeStream nextPutAll: (readStream next: 1024) ].	^ writeStream contents! !!GRCodec methodsFor: 'convenience' stamp: 'pmm 8/26/2011 09:48'!encode: aString	| writeStream |	writeStream := self encoderFor: (GRPlatform current		writeCharacterStreamOn:  (String new: aString size)).	writeStream nextPutAll: aString.	^ writeStream contents! !!GRCodec methodsFor: 'printing' stamp: 'lr 2/7/2009 10:17'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GRCodec methodsFor: 'conversion' stamp: 'lr 2/7/2009 09:41'!decoderFor: aReadStream	"Wrap aReadStream with an decoder for the codec of the receiver. Answer a read stream that delegates to and shares the state of aReadStream." 		self subclassResponsibility! !!GRCodec methodsFor: 'conversion' stamp: 'lr 2/7/2009 09:41'!encoderFor: aWriteStream	"Wrap aWriteStream with an encoder for the codec of the receiver. Answer a write stream that delegates to and shares the state of aWriteStream."		self subclassResponsibility! !!GRCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 10:16'!name	"Answer a human readable string of the receivers encoding policy."	self subclassResponsibility! !!GRCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 11:54'!url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRCodec class	instanceVariableNames: ''!!GRCodec class methodsFor: 'private' stamp: 'pmm 6/28/2009 16:40'!basicForEncoding: aString	"Create the actual instance."	self subclassResponsibility! !!GRCodec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!unsupportedEncoding: aString	"Signal an unsupported encoding."	^ GRUnsupportedEncodingError signal: 'unsupported encoding: ' , aString! !!GRCodec class methodsFor: 'testing' stamp: 'pmm 6/28/2009 16:40'!supportsEncoding: aString	"Answer whether the the given encoding name is supported by this codec class."	self subclassResponsibility! !!GRCodec class methodsFor: 'accessing' stamp: 'jf 2/7/2009 20:27'!codecs	"Answer a collection of possible codecs of the receiver. To be overridden by concrete subclasses."	^ #()! !!GRCodec class methodsFor: 'accessing' stamp: 'pmm 6/28/2009 16:35'!allCodecs	"Answer all codecs supported in this system. This is a collection of codec instances."	^ self subclasses		inject: self codecs asArray		into: [ :result :each | result , each allCodecs ]! !!GRCodec class methodsFor: 'instance creation' stamp: 'lr 7/25/2011 19:46'!forEncoding: aString	"Answer a new codec instance for the given encoding name. Raise an WAUnsupportedEncodingError if the encoding name is not supported by this image."	self allSubclassesDo: [ :each | 		(each supportsEncoding: aString)			ifTrue: [ ^ each basicForEncoding: aString ] ].	^ self unsupportedEncoding: aString! !GRObject subclass: #GRDelegatingStream	instanceVariableNames: 'stream'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRDelegatingStream commentStamp: 'pmm 6/25/2012 20:20' prior: 0!A GRDelegatingStream is a wrapper around a write stream and defines common behavior.Instance Variables	stream:		<WriteStream>stream	- a WriteStream!!GRDelegatingStream methodsFor: 'initialization' stamp: 'pmm 9/1/2012 15:25'!initializeOn: aStream	self initialize.	stream := aStream! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'JohanBrichau 9/14/2013 12:20'!position	^ stream position! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:05'!size	^ stream size! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'ar 8/4/2010 20:54'!reset	"Reset the stream"	stream reset! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:06'!flush	stream flush! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:05'!contents	^ stream contents! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!next: anInteger	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!nextPut: aCharacter	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!nextPutAll: aString	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:11'!next	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:11'!crlf	self nextPut: Character cr; nextPut: Character lf! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'lr 9/25/2011 10:11'!print: anObject	anObject printOn: self! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'jf 7/28/2009 15:55'!space	self nextPut: Character space! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'jf 7/28/2009 15:56'!tab	self nextPut: Character tab! !!GRDelegatingStream methodsFor: 'testing' stamp: 'pmm 2/20/2009 22:04'!atEnd	^ stream atEnd! !!GRDelegatingStream methodsFor: 'testing' stamp: 'NorbertHartl 10/7/2010 08:21'!isStream	^ true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRDelegatingStream class	instanceVariableNames: ''!!GRDelegatingStream class methodsFor: 'instance creation' stamp: 'pmm 10/30/2010 18:53'!on: aStream	^ self basicNew initializeOn: aStream! !GRDelegatingStream subclass: #GRCodecStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!GRCodecStream is the abstract base class for codec streams!GRObject subclass: #GRInflector	instanceVariableNames: ''	classVariableNames: 'InflectionRules Uninflected'	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRInflector commentStamp: 'lr 12/27/2008 09:43' prior: 0!The Inflector transforms words from singular to plural.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRInflector class	instanceVariableNames: ''!!GRInflector class methodsFor: 'accessing' stamp: 'jok 3/22/2010 12:04'!pluralize: aString	| string |	string := aString asLowercase.	Uninflected do: [ :each |		(string endsWithSubCollection: each)			ifTrue: [ ^ aString ] ].	InflectionRules do: [ :rule |		(string endsWithSubCollection: rule first)			ifTrue: [ ^ (aString allButLast: rule third) , rule second ] ].	^ aString , 's'! !!GRInflector class methodsFor: 'initialization' stamp: 'pmm 2/24/2008 18:31'!initialize	Uninflected := #('bison' 'bream' 'breeches' 'britches' 'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps' 'debris' 'deer' 'diabetes' 'djinn' 'eland' 'elk' 'equipment' 'fish' 'flounder' 'gallows' 'graffiti' 'headquarters' 'herpes' 'high-jinks' 'homework' 'information' 'innings' 'ities' 'itis' 'jackanapes' 'mackerel' 'measles' 'mews' 'money' 'mumps' 'news' 'ois' 'pincers' 'pliers' 'pox' 'proceedings' 'rabies' 'rice' 'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'sheep' 'species' 'swine' 'trout' 'tuna' 'whiting' 'wildebeest').	InflectionRules := #(('man' 'en' 2) ('child' 'ren' 0) ('cow' 'kine' 3) ('penis' 'es' 0) ('sex' 'es' 0) ('person' 'ople' 4) ('octopus' 'es' 0) ('quiz' 'zes' 0) ('ox' 'en' 0) ('louse' 'ice' 4) ('mouse' 'ice' 4) ('matrix' 'ices' 2) ('vertix' 'ices' 2) ('vertex' 'ices' 2) ('indix' 'ices' 2) ('index' 'ices' 2) ('x' 'es' 0) ('ch' 'es' 0) ('ss' 'es' 0) ('sh' 'es' 0) ('ay' 's' 0) ('ey' 's' 0) ('iy' 's' 0) ('oy' 's' 0) ('uy' 's' 0) ('y' 'ies' 1) ('alf' 'ves' 1) ('elf' 'ves' 1) ('olf' 'ves' 1) ('arf' 'ves' 1) ('nife' 'ves' 2) ('life' 'ves' 2) ('wife' 'ves' 2) ('sis' 'es' 2) ('tum' 'a' 2) ('ium' 'a' 2) ('buffalo' 'es' 0) ('tomato' 'es' 0) ('buffalo' 'es' 0) ('bus' 'es' 0) ('alias' 'es' 0) ('status' 'es' 0) ('octopus' 'i' 2) ('virus' 'i' 2) ('axis' 'es' 2) ('s' '' 0))! !GRError subclass: #GRInvalidUtf8Error	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRInvalidUtf8Error commentStamp: 'pmm 1/10/2009 22:29' prior: 0!A WAInvalidUtf8Error signals that the input is not valid UTF-8.!GRCodec subclass: #GRNullCodec	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRNullCodec commentStamp: 'pmm 9/14/2013 15:52' prior: 0!The null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.!!GRNullCodec methodsFor: 'convenience' stamp: 'pmm 8/19/2014 10:00'!decode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'convenience' stamp: 'pmm 8/19/2014 10:00'!encode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:28'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aReadStream! !!GRNullCodec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:28'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aWriteStream! !!GRNullCodec methodsFor: 'accessing' stamp: 'pmm 5/26/2010 07:07'!name	^ GRNullCodec codecName! !!GRNullCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 12:06'!url	"The selfish method. Let's do it with ourselves."		^ self! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRNullCodec class	instanceVariableNames: ''!!GRNullCodec class methodsFor: 'accessing' stamp: 'pmm 5/26/2010 07:07'!codecName	^ '(none)'! !!GRNullCodec class methodsFor: 'accessing' stamp: 'jf 2/7/2009 20:27'!codecs	^ Array with: self new! !!GRNullCodec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!basicForEncoding: aString	^ self new! !!GRNullCodec class methodsFor: 'testing' stamp: 'lr 7/25/2011 19:46'!supportsEncoding: aString	^ aString isNil! !GRCodecStream subclass: #GRNullCodecStream	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRNullCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!A WANullCodecStream is a WriteStream on a String on which you can both put binary and character data without encoding happening.Instance Variables	stream:		<WriteStream>stream	- a WriteStream on a String!!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:50'!next	^ stream next! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/16/2009 08:52'!nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				stream nextPut: (Character codePoint: (aStringOrByteArray at: index)) ] ]! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/16/2009 08:52'!nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character codePoint: aCharacterOrByte) ]! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:50'!next: anInteger	^ stream next: anInteger! !GRObject subclass: #GRPrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 10:37'!print: anObject	^ String streamContents: [ :stream | self print: anObject on: stream ]! !!GRPrinter methodsFor: 'printing' stamp: 'lr 7/25/2008 19:51'!print: anObject on: aStream	"Subclasses override this method to produce some output."! !!GRPrinter methodsFor: 'operators' stamp: 'jf 9/30/2009 00:33'!, aPrinter 	^ GRSequentialPrinter new , self , aPrinter! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString center: aCharacter to: anInteger	"Pad to the center of aString with aCharacter to at least anInteger characters."	| result index |	anInteger <= aString size		ifTrue: [ ^ aString ].	index := (anInteger - aString size) // 2.	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: index + 1		to: index + aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString left: aCharacter to: anInteger	"Pad to the left side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: anInteger - aString size + 1		to: anInteger		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString right: aCharacter to: anInteger	"Pad to the right side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: 1		to: aString size		with: aString		startingAt: 1.	^ result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRPrinter class	instanceVariableNames: ''!!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:05'!isoTime	"Ansers a printer that formats time according to ISO(HH:MM:SS) E.g. 12:23:34"		^ self paddedHour24 , $: , self paddedMinute , $: , self paddedSecond! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!httpDate	"Answers a printer that formats dates for HTTP1.1 (RFC 2616)"	^ self rfc1123! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!rfc1123	"Answers a printer that formats dates for HTTP1.1 (RFC 1123). Eg.	Sun, 06 Nov 1994 08:49:37 GMT "		^ GRMappedPrinter 		block: [ :date | 			"For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time)"			date asUTC ]		next: GRSequentialPrinter new , self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:02'!rfc822WithTimeZone: aString	"Answers a privter that formats dates according to RFC 822 (email) with the given time zone String. Eg.	Sun, 31 Aug 2008 19:41:46 <aString>"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , aString! !!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:06'!isoDate	"Ansers a printer that formats dates according to ISO(YYYY-MM-DD) E.g. 2003-12-24"	^ self paddedYear , $- , self paddedMonth , $- , self paddedDay! !!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:06'!rfc822	"Answers a printer that formats dates according to RFC 822 (email). Eg.	Sun, 31 Aug 2008 19:41:46 +0200"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , self offsetSign , self absOffsetHoursPadded , self absOffsetMinutesPadded! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!cookieTimestamp	"Netscape's original proposal defined an Expires header that took a date value in a fixed-length variant format in place of Max-Age: Wdy, DD-Mon-YY HH:MM:SS GMT"	^ GRMappedPrinter		block: [ :timestamp | timestamp asUTC ]		next: self abbreviatedWeekName , ', ' , self paddedDay , '-' , self abbreviatedMonthName , '-' , self paddedYear , ' ' , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'jf 9/30/2009 00:33'!swissCurrency	^ GRSequentialPrinter new , 'CHF ' , GRSignPrinter new , (GRNumberPrinter new			separator: $';			precision: 2;			accuracy: 0.05;			yourself)! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'jf 9/30/2009 00:33'!usCurrency	^ GRSignPrinter new , $$ , (GRNumberPrinter new			separator: $,;			precision: 2;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!weekName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date dayOfWeek ]! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 13:59'!abbreviatedMonthName	^ self monthName: #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!absOffsetMinutesPadded	^ GRMappedPrinter 		block: [ :date | date offset minutes abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!absOffsetHoursPadded	^ GRMappedPrinter 		block: [ :date | date offset hours abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:33'!offsetSign	^ GRMappedPrinter 		block: [ :date | date offset ]		next: (GRSignPrinter new				positivePrinter: $+;				negativePrinter: $-;				yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!monthName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date monthIndex ]! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: (self numberWithAtLeastDigits: 4)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 14:25'!abbreviatedWeekName	^ self weekName: #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 14:25'!fullWeekName	^ self weekName: #('Sunday' 'Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 13:59'!fullMonthName	^ self monthName: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December')! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!binaryFileSize	^ GRUnitPrinter base: 1024 units: #('byte' 'bytes' 'KiB' 'MiB' 'GiB' 'TiB' 'PiB' 'EiB' 'ZiB' 'YiB')! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!decimalFileSize	^ GRUnitPrinter base: 1000 units: #('byte' 'bytes' 'kB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB')! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!numberWithAtLeastDigits: anInteger	^ GRNumberPrinter new		padding: $0;		digits: anInteger;		yourself! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: (GRNumberPrinter new				padding: $0;				digits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: GRNumberPrinter new! !GRPrinter subclass: #GRMappedPrinter	instanceVariableNames: 'next block'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRMappedPrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 11:26'!print: anObject on: aStream	next print: (block value: anObject) on: aStream! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:29'!block: aBlock	block := aBlock! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:27'!next: aPrinter	next := aPrinter! !!GRMappedPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:26'!initialize	super initialize.	self block: [ :value | value ]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRMappedPrinter class	instanceVariableNames: ''!!GRMappedPrinter class methodsFor: 'instance creation' stamp: 'lr 7/24/2008 11:32'!block: aBlock next: aPrinter	^ self new 		block: aBlock;		next: aPrinter;		yourself! !GRPrinter subclass: #GRNumberPrinter	instanceVariableNames: 'characters base delimiter digits infinite nan padding accuracy precision separator'	classVariableNames: 'NumbersToCharactersLowercase NumbersToCharactersUppercase'	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRNumberPrinter commentStamp: 'pmm 2/1/2014 13:27' prior: 0!A GRNumberPrinter prints numbers (integers and floats) in various formats in a platform independent way.Instance Variables	accuracy:	<UndefinedObject|Float>	base:		<Integer>	delimiter:	<UndefinedObject|Character>	digits:		<UndefinedObject|Integer>	infinite:		<UndefinedObject|String>	nan:			<UndefinedObject|String>	padding:	<UndefinedObject|Character>	precision:	<Integer>	separator:	<UndefinedObject|Character>!!GRNumberPrinter methodsFor: 'actions' stamp: 'lr 2/6/2010 10:17'!uppercase	"Use uppercase characters for numbers of base 10 and higher."		self characters: NumbersToCharactersUppercase! !!GRNumberPrinter methodsFor: 'actions' stamp: 'lr 2/6/2010 10:17'!lowercase	"Use lowercase characters for numbers of base 10 and higher."	self characters: NumbersToCharactersLowercase! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 7/24/2008 14:34'!separate: aString left: aCharacter	"Separate from the left side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ index \\ 3 = 1 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 5/13/2010 12:26'!digitsOf: aNumber base: aBaseInteger	"Answer the absolute digits of aNumber in the base aBaseInteger."	| integer stream next |	integer := aNumber truncated abs.	integer = 0 ifTrue: [ ^ '0' ].	stream := WriteStream on: (String new: 10).	[ integer > 0 ] whileTrue: [		next := integer quo: aBaseInteger.		stream nextPut: (characters 			at: 1 + integer - (next * aBaseInteger)).		integer := next ].	^ stream contents reverse! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 7/24/2008 14:34'!separate: aString right: aCharacter	"Separate from the right side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ size - index \\ 3 = 2 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:58'!initialize	super initialize.	self lowercase.	self base: 10.	self delimiter: $..	self infinite: 'Infinite'.	self nan: 'NaN'.	self padding: $ .	self precision: 0! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:39'!printNaN: anInteger on: aStream	nan isNil		ifFalse: [ aStream nextPutAll: nan ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'pmm 9/15/2013 11:45'!printFloat: aNumber on: aStream	| multiplier rounded |	multiplier := base raisedTo: precision.	rounded := aNumber roundTo: (accuracy ifNil: [ multiplier reciprocal ]).	self printInteger: rounded on: aStream.	delimiter isNil		ifFalse: [ aStream nextPut: delimiter ].	self printFraction: rounded fractionPart abs * multiplier on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:27'!print: aNumber on: aStream	aNumber isNaN		ifTrue: [ ^ self printNaN: aNumber on: aStream ].	aNumber isInfinite 		ifTrue: [ ^ self printInfinite: aNumber on: aStream ].	precision = 0		ifTrue: [ self printInteger: aNumber on: aStream ]		ifFalse: [ self printFloat: aNumber on: aStream ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 6/4/2009 21:41'!printFraction: aNumber on: aStream	| result |	result := self		pad: (self digitsOf: aNumber rounded base: base)		left: $0 to: precision.	separator isNil		ifFalse: [ result := self separate: result left: separator ].	aStream nextPutAll: result! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 12:39'!printInteger: aNumber on: aStream	| result |	result := self digitsOf: aNumber integerPart base: base.	separator isNil		ifFalse: [ result := self separate: result right: separator ].	(digits isNil or: [ padding isNil ])		ifFalse: [ result := self pad: result left: padding to: digits ].	aStream nextPutAll: result! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:39'!printInfinite: aNumber on: aStream	infinite isNil		ifFalse: [ aStream nextPutAll: infinite ]! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 3/24/2008 16:19'!infinite: aString	"The string that should be displayed if the number is positive or negative infinity."		infinite := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:50'!digits: anInteger	"The number of digits to be printed in the integer part."	digits := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 3/24/2008 16:19'!nan: aString	"The string that should be displayed if the number is not a number."		nan := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:16'!precision: anInteger	"The number of digits to be printed in the fraction part."		precision := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 14:36'!delimiter: aCharacter	"The delimiter to separate the integer and fraction part of the number."	delimiter := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 2/6/2010 10:17'!characters: aString	"The characters to be used to convert a number to a string."	characters := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:13'!accuracy: aFloat	"Round towards the nearest number that is a multiple of aFloat."		accuracy := aFloat! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:16'!base: anInteger	"The numeric base to which the number should be printed."	base := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:51'!padding: aCharacter	"The padding for the integer part."	padding := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 14:35'!separator: aCharacter	"Separator character to be used to group digits."	separator := aCharacter! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRNumberPrinter class	instanceVariableNames: ''!!GRNumberPrinter class methodsFor: 'initialization' stamp: 'lr 1/23/2009 21:18'!initialize	NumbersToCharactersLowercase := '0123456789abcdefghijklmnopqrstuvwxyz'.	NumbersToCharactersUppercase := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'! !GRPrinter subclass: #GROrdinalizePrinter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GROrdinalizePrinter methodsFor: 'private' stamp: 'lr 2/16/2008 19:37'!ordinalize: anInteger	^ (anInteger \\ 100 between: 11 and: 13)		ifTrue: [ 'th' ]		ifFalse: [ 			#('st' 'nd' 'rd')				at: anInteger \\ 10 				ifAbsent: [ 'th' ] ]! !!GROrdinalizePrinter methodsFor: 'printing' stamp: 'lr 2/16/2008 19:32'!print: anObject on: aStream	aStream nextPutAll: (self ordinalize: anObject integerPart)! !GRPrinter subclass: #GRPluggablePrinter	instanceVariableNames: 'block'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRPluggablePrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 12:49'!block: aBlock	block := aBlock! !!GRPluggablePrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:15'!initialize	super initialize.	self block: [ :value | String new ]! !!GRPluggablePrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 12:49'!print: anObject on: aStream	aStream nextPutAll: (block value: anObject)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRPluggablePrinter class	instanceVariableNames: ''!!GRPluggablePrinter class methodsFor: 'instance creation' stamp: 'lr 7/24/2008 13:59'!on: aBlock	^ self new block: aBlock! !GRPrinter subclass: #GRSequentialPrinter	instanceVariableNames: 'parts'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRSequentialPrinter methodsFor: 'operators' stamp: 'lr 2/7/2008 11:33'!, aConverter	parts add: aConverter! !!GRSequentialPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 10:29'!print: anObject on: aStream 	parts do: [ :each | each print: anObject on: aStream ]! !!GRSequentialPrinter methodsFor: 'initialization' stamp: 'lr 2/7/2008 10:28'!initialize	super initialize.	parts := OrderedCollection new! !GRPrinter subclass: #GRSignPrinter	instanceVariableNames: 'negativePrinter positivePrinter'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRSignPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:28'!negativePrinter: aPrinter	"The printer to be used when the number is negative."		negativePrinter := aPrinter! !!GRSignPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:28'!positivePrinter: aPrinter	"The printer to be used when the number is zero or positive."		positivePrinter := aPrinter! !!GRSignPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:15'!initialize	super initialize.	self negativePrinter: $-.	self positivePrinter: nil! !!GRSignPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 13:27'!print: anObject on: aStream 	anObject negative		ifTrue: [ negativePrinter print: anObject on: aStream ]		ifFalse: [ positivePrinter print: anObject on: aStream ]! !GRPrinter subclass: #GRStringPrinter	instanceVariableNames: 'trim length pad character'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRStringPrinter methodsFor: 'printing' stamp: 'lr 2/6/2010 10:10'!print: anObject on: aStream 	| string |	string := anObject greaseString.	trim isNil		ifFalse: [ string := string perform: trim ].	length isNil ifFalse: [		length < string size 			ifTrue: [ string := string copyFrom: 1to: length ].		(pad isNil or: [ character isNil ])			ifFalse: [ string := self perform: pad with: string with: character with: length ] ].	aStream nextPutAll: string! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:01'!padRight	"Pad to the right."		pad := #pad:right:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:01'!padCenter	"Pad to the center."		pad := #pad:center:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:02'!padLeft	"Pad to the left."		pad := #pad:left:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 2/6/2010 10:11'!padNone	"Do not pad the input."		pad := nil! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 2/6/2010 10:11'!trimNone	"Do not trim the input."	trim := nil! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimRight	"Trim to the left and to the right."	trim := #trimRight! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimBoth	"Trim to the left and to the right."	trim := #trimBoth! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimLeft	"Trim to the left and to the right."	trim := #trimLeft! !!GRStringPrinter methodsFor: 'accessing' stamp: 'lr 1/23/2009 21:40'!character: aCharacter	"The character to pad the string with."		character := aCharacter! !!GRStringPrinter methodsFor: 'accessing' stamp: 'lr 1/23/2009 22:00'!length: anInteger	"The maximal size of the string, or the size to pad to."	length := anInteger! !!GRStringPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:11'!initialize	super initialize.	self character: $ ; length: nil.	self trimNone; padNone! !GRPrinter subclass: #GRUnitPrinter	instanceVariableNames: 'integerPrinter fractionPrinter units base'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!!GRUnitPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:07'!initialize	super initialize.	self integerPrinter: (GRNumberPrinter new		precision: 0;		yourself).	self fractionPrinter: (GRNumberPrinter new		precision: 1;		yourself)! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:23'!fractionPrinter: aPrinter	fractionPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:23'!integerPrinter: aPrinter	integerPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 9/22/2008 23:27'!base: anInteger	base := anInteger! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 9/22/2008 23:27'!units: anArray	units := anArray! !!GRUnitPrinter methodsFor: 'printing' stamp: 'lr 9/22/2008 23:28'!print: anObject on: aStream	anObject = 1		ifTrue: [ ^ self print: anObject unit: units first on: aStream ].	units allButFirst		inject: anObject asFloat		into: [ :value :each |			value < base				ifFalse: [ value / base ]				ifTrue: [ ^ self print: value unit: each on: aStream ] ]! !!GRUnitPrinter methodsFor: 'printing' stamp: 'lr 9/22/2008 23:36'!print: aNumber unit: aString on: aStream	(units first = aString or: [ units second = aString ])		ifTrue: [ integerPrinter print: aNumber on: aStream ]		ifFalse: [ fractionPrinter print: aNumber on: aStream ].	aStream nextPut: $ ; nextPutAll: aString! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRUnitPrinter class	instanceVariableNames: ''!!GRUnitPrinter class methodsFor: 'instance creation' stamp: 'lr 9/22/2008 23:34'!base: anInteger units: anArray	^ self new 		base: anInteger;		units: anArray;		yourself! !GRError subclass: #GRUnsupportedEncodingError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Text'!GRInflector initialize!GRNumberPrinter initialize!Error subclass: #GRError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!!GRError commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRError instead of Error.!Notification subclass: #GRNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!!GRNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRNotification instead of Notification.!GRNotification subclass: #GRDeprecatedApiNotification	instanceVariableNames: 'details'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Exceptions'!!GRDeprecatedApiNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This notification is signaled whenever a deprecated message is sent.see WAObject>>#greaseDeprecatedApi:details: !!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'jf 9/24/2008 10:28'!details	^ details! !!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'jf 9/24/2008 10:28'!details: anObject	details := anObject! !GRObject subclass: #GRDelayedSend	instanceVariableNames: 'receiver message'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!!GRDelayedSend commentStamp: 'NickAger 3/20/2012 09:04' prior: 0!A GRDelayedSend is a future message send of a message to an object. Some of the arguments can be predefined. Instances are intended to be interchangeable with blocks.This class should conform the ANSI (block) valuable protocol. Unlike a block, a GRDelayedSend is not a closure so doesn't hold onto the method context. GRDelayedSend provides similar, but portable, functionality to Pharo's MessageSend.This is an abstract class. Use the methods in the 'instance-creation' protocol on the class side to create intances.Instance Variables	receiver:		<Object>	selector:		<Symbol>receiver	- the object receiving the messageselector	- the message selector sent to the receiver!!GRDelayedSend methodsFor: 'accessing' stamp: 'jf 7/10/2011 23:32'!argumentCount	"Answer the number of arguments that must be provided to the receiver when sending it."		^ message argumentCount! !!GRDelayedSend methodsFor: 'accessing' stamp: 'lr 1/11/2009 11:44'!fixCallbackTemps	"For polymorphism with BlockContext>>#fixCallbackTemps."! !!GRDelayedSend methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:23'!initializeWithReceiver: anObject message: aDelayedSendMessage	self initialize.	receiver := anObject.	message := aDelayedSendMessage! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:45'!value: anObject	^ self valueWithArguments: (Array with: anObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:45'!value	^ self valueWithArguments: #()! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'jf 7/10/2011 23:24'!valueWithArguments: anArray	^ message valueFor: receiver withArguments: anArray! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'jf 7/10/2011 23:24'!valueWithPossibleArguments: anArray	^ message valueFor: receiver withPossibleArguments: anArray! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:46'!value: aFirstObject value: aSecondObject	^ self valueWithArguments: (Array with: aFirstObject with: aSecondObject)! !!GRDelayedSend methodsFor: 'printing' stamp: 'jf 7/10/2011 23:23'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' receiver: '; print: receiver.	aStream nextPut: $ .	message printOn: aStream! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRDelayedSend class	instanceVariableNames: ''!!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:48'!empty	^ self receiver: nil selector: #yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'pmm 1/10/2009 23:44'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:33'!receiver: anObject selector: aSymbol 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRUnboundMessage selector: aSymbol);		yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:49'!new	^ self empty! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:33'!receiver: anObject selector: aSymbol arguments: anArray 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRBoundMessage selector: aSymbol arguments: anArray);		yourself! !GRObject subclass: #GRDelayedSendMessage	instanceVariableNames: 'selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!!GRDelayedSendMessage commentStamp: 'NickAger 3/19/2012 11:20' prior: 0!GRDelayedSendMessage is an abstract base for objects that provide currying functionality for GRDelayedSend!!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:19'!valueFor: receiver withPossibleArguments: anArray	"Send the message to receiver with as many of the arguments in anArray as possible. Answer the result.	Error if not enough arguments are available for the selector."	| allArguments |	allArguments := self mergeArguments: anArray.		^ allArguments size < selector numArgs		ifTrue: [ self invalidArgumentCount ]		ifFalse: [ self basicPerformFor: receiver withArguments: (allArguments first: selector numArgs) ]! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:02'!argumentCount	"Answer the number of arguments that must be provided when sending this message."		self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:37'!valueFor: receiver withArguments: anArray	"Send the message to receiver with the arguments in anArray. Answer the result.	Signal an error if the number of arguments does not match the selector."		^ self basicPerformFor: receiver withArguments: (self mergeArguments: anArray)! !!GRDelayedSendMessage methodsFor: 'printing' stamp: 'jf 7/10/2011 23:36'!printOn: aStream	aStream nextPutAll: 'selector: '; print: selector! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:25'!invalidArgumentCount	GRInvalidArgumentCount signal! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:14'!mergeArguments: anArray	self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:20'!basicPerformFor: receiver withArguments: anArray	^ anArray size = selector numArgs		ifTrue: [ receiver perform: selector withArguments: anArray ]		ifFalse: [ self invalidArgumentCount ]! !!GRDelayedSendMessage methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:01'!initializeWithSelector: aSymbol	self initialize.	selector := aSymbol! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRDelayedSendMessage class	instanceVariableNames: ''!!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:27'!selector: aSymbol	^ self basicNew		initializeWithSelector: aSymbol;		yourself! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:28'!new	^ self selector: #yourself! !GRDelayedSendMessage subclass: #GRBoundMessage	instanceVariableNames: 'arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!!GRBoundMessage commentStamp: 'jf 3/14/2009 11:04' prior: 0!A delayed send that has some or all of the arguments defined in advance. Additionally supplied arguments will be added, if possible, to these when the object is evaluate.Instance Variables	arguments:		<Array>arguments	- the predefined arguments!!GRBoundMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:38'!argumentCount	^ selector numArgs - arguments size! !!GRBoundMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:14'!mergeArguments: anArray	^ arguments , anArray! !!GRBoundMessage methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:21'!initializeWithSelector: aSymbol arguments: anArray	self initializeWithSelector: aSymbol.	arguments := anArray asArray! !!GRBoundMessage methodsFor: 'printing' stamp: 'lr 1/11/2009 11:50'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' arguments: '; print: arguments! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRBoundMessage class	instanceVariableNames: ''!!GRBoundMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:30'!selector: aSymbol	^ self selector: aSymbol arguments: #()! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:29'!selector: aSymbol arguments: anArray	^ self basicNew		initializeWithSelector: aSymbol arguments: anArray;		yourself! !GRError subclass: #GRInvalidArgumentCount	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!!GRInvalidArgumentCount commentStamp: 'jf 3/14/2009 11:05' prior: 0!Signaled whenever a message is sent with the incorrect number of arguments.!GRDelayedSendMessage subclass: #GRUnboundMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Utilities'!!GRUnboundMessage commentStamp: 'jf 3/14/2009 11:03' prior: 0!A delayed send that has none of the arguments defined in advance.!!GRUnboundMessage methodsFor: 'private' stamp: 'lr 7/25/2011 19:52'!mergeArguments: anArray	^ anArray! !!GRUnboundMessage methodsFor: 'delegation' stamp: 'lr 1/11/2009 13:02'!argumentCount	^ selector numArgs! !Object subclass: #GRObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!!GRObject commentStamp: 'pmm 9/14/2013 15:52' prior: 0!A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.!!GRObject methodsFor: 'error handling' stamp: 'jf 3/13/2009 16:40'!error: aString	^ self class error: aString! !!GRObject methodsFor: 'initialization' stamp: 'jf 3/13/2009 16:14'!initialize! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRObject class	instanceVariableNames: ''!!GRObject class methodsFor: 'error handling' stamp: 'jf 3/13/2009 16:40'!error: aString	^ self defaultErrorClass signal: aString! !!GRObject class methodsFor: 'error handling' stamp: 'jf 9/30/2009 00:20'!defaultErrorClass	^ GRError! !!GRObject class methodsFor: 'instance creation' stamp: 'jf 3/13/2009 16:28'!new	^ self basicNew initialize! !GRDelegatingStream subclass: #GRCountingStream	instanceVariableNames: 'count'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!!GRCountingStream commentStamp: 'pmm 6/25/2012 20:39' prior: 0!A GRCountingStream counts how many elements have been added to it. This is necessary because the underlying stream may inflate the number of elements in the stream.Instance Variables:	count	<Integer>		count  - number of elements added to this stream!!GRCountingStream methodsFor: 'accessing' stamp: 'pmm 6/25/2012 20:27'!reset	super reset.	count := 0! !!GRCountingStream methodsFor: 'accessing' stamp: 'pmm 6/25/2012 20:26'!count	^ count! !!GRCountingStream methodsFor: 'initialization' stamp: 'pmm 6/25/2012 20:26'!initialize	super initialize.	count := 0! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:46'!next: anInteger	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:28'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	super greaseNext: anInteger putAll: aCollection startingAt: startIndex.	count := count + anInteger! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:45'!nextPutAll: aString	stream nextPutAll: aString.	count := count + aString size	! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:46'!next	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:45'!nextPut: aCharacter	stream nextPut: aCharacter.	count := count + 1	! !GRObject subclass: #GRPackage	instanceVariableNames: 'name description dependencies license url'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!!GRPackage commentStamp: 'pmm 9/14/2013 15:53' prior: 0!I am a platform independent package representation. I know my name, description, my dependencies, the license and the repository URL. Packages are declared by creating a class side extension method that answers a configured package instance. The expression    GRPackage packagesanswers the collection of the complete package graph.!!GRPackage methodsFor: 'dependencies' stamp: 'JohanBrichau 3/26/2016 15:54'!resolveWith: aDictionary	dependencies := dependencies 		collect: [ :each |			aDictionary at: each ifAbsent: [				"if Foo-Pharo-Bar fails try Foo-Pharo20-Bar and Foo-Pharo30-Bar"				(each indexOfSubCollection: '-Pharo-' startingAt: 1) ~= 0 ifTrue: [ 					"try -Pharo20-"					aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo20-') ifAbsent: [						"try -Pharo30-"						aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo30-') ifAbsent: [							"try -Pharo40-"							aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo40-') ifAbsent: [								"try -Pharo50-"								aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo50-') ifAbsent: [									self error: self name printString , ' depends on unknown package ' , each printString ] ] ] ] ] ] ]! !!GRPackage methodsFor: 'dependencies' stamp: 'lr 2/17/2010 15:18'!allDependencies	"Answer all dependencies on which this package depends."	^ self addDependenciesTo: OrderedCollection new! !!GRPackage methodsFor: 'dependencies' stamp: 'merged 10/20/2008 09:33'!addDependency: aString	dependencies add: aString! !!GRPackage methodsFor: 'dependencies' stamp: 'jf 3/15/2009 17:00'!dependencies	"Return a collection of package names on which this package depends."	^ dependencies! !!GRPackage methodsFor: 'private' stamp: 'lr 9/5/2009 18:35'!addDependenciesTo: aCollection	(aCollection includes: self) ifFalse: [		self dependencies			do: [ :each | each addDependenciesTo: aCollection ].		aCollection add: self ].	^ aCollection! !!GRPackage methodsFor: 'initialization' stamp: 'lr 2/17/2010 15:06'!initialize	super initialize.	dependencies := OrderedCollection new.	license := #MIT! !!GRPackage methodsFor: 'testing' stamp: 'lr 10/25/2009 15:19'!isLGPL	^ self license = #LGPL! !!GRPackage methodsFor: 'testing' stamp: 'lr 10/25/2009 15:19'!isMIT	^ self license = #MIT! !!GRPackage methodsFor: 'printing' stamp: 'merged 10/20/2008 09:24'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:57'!greaseUrl	^ 'http://smalltalkhub.com/mc/Seaside/Grease11/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:59'!seasideLGPLUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30LGPL/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:58'!seasideUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside31/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:59'!seasideAddonsUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30Addons/main'! !!GRPackage methodsFor: 'accessing' stamp: 'merged 10/20/2008 09:23'!description	"Answer a short description of the package."	^ description! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/17/2010 15:18'!url: aStringOrSymbol	"Set the base-URL of the package, or a symbol referring to a method in this class that answers the URL. This setting is only meaningful for platforms that can directly access Monticello repositories."	url := aStringOrSymbol! !!GRPackage methodsFor: 'accessing' stamp: 'obi 10/8/2009 07:51'!license: aSymbol	license := aSymbol! !!GRPackage methodsFor: 'accessing' stamp: 'lr 10/25/2009 11:26'!name: aString	name := aString! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/17/2010 15:18'!name	"Answer the name of the package. This string should be useable to identify the platform specific native package object, e.g. the Monticello package name."	^ name! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/10/2010 11:18'!url	"Answer the base-URL of the package. This string is only meaningful for platforms that can directly access Monticello repositories."	^ url isSymbol		ifTrue: [ self perform: url ]		ifFalse: [ url ]! !!GRPackage methodsFor: 'accessing' stamp: 'lr 10/25/2009 11:26'!description: aString	description := aString! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/10/2010 11:18'!license	"Answer the current license of this package, by default MIT is used."	^ license! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRPackage class	instanceVariableNames: ''!!GRPackage class methodsFor: 'querying' stamp: 'JohanBrichau 12/15/2013 18:27'!grPackages	"Answer a list of all registered packages. A package is registered by adding a class extension to the receiving class answering an instance of the receiving class."	| packages package |	packages := Dictionary new.	self class selectors do: [ :each |		(each numArgs = 0 and: [ each ~= #grPackages ]) ifTrue: [ 			package := self perform: each.			packages at: package name put: package ] ].	packages do: [ :each | each resolveWith: packages ].	^ packages values! !!GRPackage class methodsFor: 'accessing' stamp: 'pmm 9/12/2013 16:00'!greaseCore	^ self new		name: 'Grease-Core';		description: 'The main package of the Grease compatibility layer.';		url: #greaseUrl;		yourself! !GRObject subclass: #GRPlatform	instanceVariableNames: ''	classVariableNames: 'Current'	poolDictionaries: ''	category: 'Grease-Core'!!GRPlatform commentStamp: 'jf 2/6/2009 16:05' prior: 0!The abstract platform implementation. Each platform should provide a subclass implementing any abstract methods and overriding any other methods as necessary.Default implementations should be provided here when possible/useful but default implementations MUST be valid on ALL PLATFORMS so it is rarely practical. VA Smalltalk flags sends of uknown messages so even these must be known to exist on all platforms.Common cases where default implementations *are* appropriate are where there is a standard implementation that is valid on all platforms but one or more platforms have an additional, optimized implementation that should be used instead.All classes and methods used by methods of this class should be either:  + included in the Seaside-Platform package;  + defined by the ANSI Smalltalk standard; or  + (not ideal) referenced via 'Smalltalk at: #ClassName'.!!GRPlatform methodsFor: 'encoding' stamp: 'pmm 8/27/2011 15:12'!base64Decode: aString	"Base64 decode the given String and answer the result as a String."	self subclassResponsibility! !!GRPlatform methodsFor: 'bindings' stamp: 'pmm 8/23/2014 11:42'!bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ Smalltalk associationAt: aClass name! !!GRPlatform methodsFor: 'exceptions' stamp: 'jf 1/22/2009 02:11'!openDebuggerOn: anError	self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'jf 1/22/2009 02:11'!stackDepth	self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'pmm 9/6/2014 12:17'!deprecationExceptionSet	"Answer the exception set that should considered besides WADeprecation."	^ ExceptionSet new! !!GRPlatform methodsFor: 'cryptography' stamp: 'jf 1/22/2009 02:11'!secureHashFor: aString	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:11'!weakDictionaryOfSize: aNumber	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'pmm 8/26/2011 09:45'!writeCharacterStreamOn: aString	"String based write stream"	^ WriteStream on: aString! !!GRPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!readWriteByteStream	"Return a ReadWriteStream on a ByteArray that stores integers 0..255		^ReadWriteStream on: ByteArray new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:10'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!readWriteCharacterStream	"Return a ReadWriteStream on a String that stores characters		^ReadWriteStream on: String new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:39'!reducedConflictDictionary	"used by Gemstone/S reduced conflict classes that can be used to avoid transaction conflicts"	^ Dictionary! !!GRPlatform methodsFor: 'factory' stamp: 'jf 9/25/2009 16:40'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.	Used by Squeak to use a secure random when avaiable."	self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'JohanBrichau 7/20/2014 17:51'!version	"Answer the Grease version"	^ (GRVersion major: 1 minor: 1 revision: 10)		yourself! !!GRPlatform methodsFor: 'version info' stamp: 'jf 2/9/2010 00:57'!versionString	^ String streamContents: [ :stream |		stream			nextPutAll: (self version greaseString);			nextPutAll: ' (';			nextPutAll: (self label);			nextPut: $) ]! !!GRPlatform methodsFor: 'version info' stamp: 'jf 2/9/2010 00:57'!label	"Answer a descriptive label string for the platform implementation"		self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2014 10:10'!localNameOf: aFilename	"Answer the local name of a file identified by an absolute file path.		Eg.	If the platform is Windwos and aFilename is 'C:\Windows\win32.dll' then it would answer 'win32.dll'.	If the platform is Unix and aFilename is '/usr/bin/vim' then it would answer 'vim'."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 20:00'!fileStreamOn: aString do: aBlock binary: aBoolean	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!removeSelector: aSymbol from: aClass	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2014 10:11'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"Write aStringOrByteArray to a file named aFileNameString in the folder aFolderString."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 20:02'!fileExists: aString	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!compile: aString into: aClass classified: aSymbol	"The trick here is to be as silently a possible so that the package is not marked dirty when running WAFileLibrary test.	This also makes running tests much faster."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:54'!ensureExistenceOfFolder: aString	"Create a folder named aString in the image directory."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'NickAger 3/9/2012 11:29'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'lr 4/15/2010 19:13'!newline	"Answer a String with the default newline character of this platform."		self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!contentsOfFile: aString binary: aBoolean	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'lr 4/15/2010 19:15'!convertToSmalltalkNewlines: aString	"Convert any line endings (CR, CRLF, LF) to the default platform newline."		aString isNil 		ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPutAll: self newline ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPutAll: self newline ]						ifFalse: [ writeStream nextPut: next ] ] ] ]! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:54'!filesIn: aPathString	"Answer a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:53'!pathSeparator	"Answer the path separator as a String, eg. '/' on Unix and '\' on Windows."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:10'!addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 16:00'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."		self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 16:00'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."		self subclassResponsibility! !!GRPlatform methodsFor: 'transactions' stamp: 'lr 7/25/2011 19:51'!doTransaction: aBlock	"for Gemstone/S compatibility	http://gemstonesoup.wordpress.com/2007/05/10/porting-application-specific-seaside-threads-to-gemstone/	use when modifying an object from an outside thread"	^ aBlock value! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRPlatform class	instanceVariableNames: ''!!GRPlatform class methodsFor: 'registration' stamp: 'jf 1/21/2009 17:08'!current: aPlatform	Current := aPlatform! !!GRPlatform class methodsFor: 'registration' stamp: 'jgf 1/25/2009 12:06'!current	^ Current! !!GRPlatform class methodsFor: 'registration' stamp: 'jf 9/30/2009 00:19'!unselect	GRPlatform current class = self ifTrue: [ GRPlatform current: nil ]! !!GRPlatform class methodsFor: 'registration' stamp: 'jf 9/30/2009 00:19'!select	GRPlatform current: self new! !GRObject subclass: #GRVersion	instanceVariableNames: 'major minor revision stageLabel stageNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core'!!GRVersion commentStamp: 'lr 2/19/2012 12:57' prior: 0!I model version numbers. I am comparable and I define a natural order.!!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!stage: aSymbol number: anInteger	stageLabel := aSymbol.	stageNumber := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!revision	^ revision! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/9/2010 00:01'!stage	^ stageLabel! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/9/2010 00:01'!stageNumber	^ stageNumber! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!revision: anInteger	revision := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!major: anInteger	major := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!minor	^ minor! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!minor: anInteger	minor := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!major	^ major! !!GRVersion methodsFor: 'converting' stamp: 'pmm 1/22/2012 16:32'!greaseString	^ String streamContents: [ :stream |		stream nextPutAll: major greaseString.		stream nextPut: $..		stream nextPutAll: (minor ifNil: [ 0 ]) greaseString.		revision isNil ifFalse: [			stream nextPut: $..			stream nextPutAll: revision greaseString ].		stageLabel isNil ifFalse: [			stream nextPutAll: stageLabel greaseString.			stageNumber isNil ifFalse: [ stream nextPutAll: stageNumber greaseString ] ] ]! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isBeta	^ stageLabel = #beta! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isFinal	^ stageLabel isNil! !!GRVersion methodsFor: 'testing' stamp: 'jf 5/22/2010 23:38'!isReleaseCandidate	^ stageLabel = #rc! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isAlpha	^ stageLabel = #alpha! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beBeta: anInteger	self stage: #beta number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'jf 5/22/2010 23:38'!beReleaseCandidate	self beReleaseCandidate: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beAlpha: anInteger	self stage: #alpha number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beBeta	self beBeta: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/9/2010 00:35'!beFinal	self stage: nil number: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beAlpha	self beAlpha: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 5/22/2010 23:37'!beReleaseCandidate: anInteger	self stage: #rc number: anInteger! !!GRVersion methodsFor: 'initialization' stamp: 'jf 2/8/2010 23:08'!initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger	self initialize.	major := majorInteger.	minor := minorInteger.	revision := revisionInteger! !!GRVersion methodsFor: 'comparing' stamp: 'lr 2/16/2010 20:55'!hash	^ (major hash bitXor: minor hash) bitXor: revision hash! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:16'!= otherVersion	^ (major = otherVersion major) and: [		((minor ifNil: [ 0 ]) = (otherVersion minor ifNil: [ 0 ])) and: [		((revision ifNil: [ 0 ] ) = (otherVersion revision ifNil: [ 0 ])) and: [		(stageLabel = otherVersion stage) and: [		(stageNumber ifNil: [ 1 ]) = (otherVersion stageNumber ifNil: [ 1 ]) ] ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:07'!>= otherVersion	^ (self < otherVersion) not! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:07'!> otherVersion	^ otherVersion < self! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:18'!< otherVersion	(major < otherVersion major) ifTrue: [ ^ true ].	(otherVersion major < major) ifTrue: [ ^ false ].	((minor ifNil: [ 0 ]) < (otherVersion minor ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion minor ifNil: [ 0 ]) < (minor ifNil: [ 0 ])) ifTrue: [ ^ false ].	((revision ifNil: [ 0 ]) < (otherVersion revision ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion revision ifNil: [ 0 ]) < (revision ifNil: [ 0 ])) ifTrue: [ ^ false ].	(stageLabel = otherVersion stage) ifTrue: [		^ ((stageNumber ifNil: [ 1 ]) < (otherVersion stageNumber ifNil: [ 1 ])) ].	stageLabel isNil ifTrue: [ ^ false ].	otherVersion stage isNil ifTrue: [ ^ true ].	^ stageLabel < otherVersion stage		! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:06'!<= otherVersion	^ (self > otherVersion) not! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRVersion class	instanceVariableNames: ''!!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/9/2010 01:01'!new	^ self major: 1! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:14'!major: majorInteger minor: minorInteger	^ self major: majorInteger minor: minorInteger revision: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:14'!major: majorInteger	^ self major: majorInteger minor: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:08'!major: majorInteger minor: minorInteger revision: revisionInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger;		yourself! !GRObject subclass: #GRSmallDictionary	instanceVariableNames: 'size keys values'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Collections'!!GRSmallDictionary commentStamp: 'jf 2/15/2010 15:51' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.!!GRSmallDictionary methodsFor: 'copying' stamp: 'lr 7/9/2007 07:50'!postCopy	super postCopy.	keys := keys copy.	values := values copy! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 7/9/2007 10:38'!values	^ values copyFrom: 1 to: size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 8/17/2007 11:52'!keysDo: aBlock	1 to: size do: [ :each | aBlock value: (keys at: each) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 6/7/2007 08:04'!keysAndValuesDo: aBlock	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 7/9/2007 10:37'!keys	^ keys copyFrom: 1 to: size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 8/20/2007 13:45'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'jf 12/29/2009 20:38'!do: aBlock	1 to: size do: [ :index | aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'printing' stamp: 'pmm 1/22/2012 16:32'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:51'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/9/2007 10:38'!size	^ size! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'jf 2/15/2010 14:40'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/12/2007 13:18'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'jf 2/15/2010 22:56'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self add: key -> value ].	^ aDictionary! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary methodsFor: 'initialization' stamp: 'jf 3/13/2009 17:48'!initialize: anInteger	self initialize.	size := 0.	keys := Array new: anInteger.	values := Array new: anInteger! !!GRSmallDictionary methodsFor: 'private' stamp: 'jf 2/15/2010 14:33'!removeIndex: index	| value |	value := values at: index.	index to: size - 1 do:			[ :i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1) ].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^ value! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 6/6/2007 19:28'!privateAt: aKey put: aValue	size = keys size ifTrue: [ self grow ].	keys at: (size := size + 1) put: aKey.	^ values at: size put: aValue! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 10/28/2007 14:42'!findIndexFor: aKey	1 to: size do: [ :index |		(keys at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 6/6/2007 19:12'!grow	| newKeys newValues |	newKeys := Array new: 2 * size.	newValues := Array new: 2 * size.	1 to: size do: [ :index |		newKeys at: index put: (keys at: index).		newValues at: index put: (values at: index) ].	keys := newKeys.	values := newValues! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 7/12/2007 13:18'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary methodsFor: 'testing' stamp: 'lr 7/9/2007 08:13'!isEmpty	^ size = 0! !!GRSmallDictionary methodsFor: 'testing' stamp: 'jf 2/15/2010 15:47'!isCollection	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'lr 10/28/2007 14:42'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRSmallDictionary class	instanceVariableNames: ''!!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'jf 3/13/2009 18:19'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'lr 1/24/2008 12:34'!new	^ self new: 3! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'jf 2/15/2010 22:50'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !GRSmallDictionary subclass: #GROrderedMultiMap	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Core-Collections'!!GROrderedMultiMap commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 15:39'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:52'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 15:39'!allAt: aKey	^ Array streamContents: [ :stream |		1 to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 14:43'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 13:24'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.991456 pm'!!String methodsFor: '*grease-core' stamp: 'jf 9/30/2009 00:37'!pluralize	^ GRInflector pluralize: self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992049 pm'!!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:19'!excerpt: aString	"Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."		^ self excerpt: aString radius: 100! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992487 pm'!!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:19'!excerpt: aString radius: anInteger	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."		^ self excerpt: aString radius: anInteger ellipsis: '...'! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992634 pm'!!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:17'!truncate	"Truncate the receiver to 30 characters."		^ self truncate: 30! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992746 pm'!!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:17'!truncate: anInteger	"Truncate the receiver to anInteger characters."		^ self truncate: anInteger ellipsis: '...'! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992844 pm'!!String methodsFor: '*grease-core' stamp: 'lr 2/7/2008 09:22'!truncate: anInteger ellipsis: aString	"Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."	^ anInteger < self size		ifTrue: [ (self copyFrom: 1 to: anInteger) , aString ]		ifFalse: [ self copy ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.992938 pm'!!String methodsFor: '*grease-core' stamp: 'pmm 12/26/2010 21:46'!greaseInteger	"Convert the receiver to an integer, answer nil if this is not a number."	| number stream negated char |	number := nil.	stream := self readStream.	negated := stream peek = $-.	negated ifTrue: [ stream next ].	[ stream atEnd not and: [ (char := stream next) isDigit ] ] whileTrue: [		number := (number isNil  ifTrue: [ 0 ]ifFalse: [ 10 * number ])			+ (char greaseInteger - $0 greaseInteger) ].	^ (number isNil or: [ negated not ]) 		ifFalse: [ number negated ]		ifTrue: [ number ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993045 pm'!!String methodsFor: '*grease-core' stamp: 'lr 7/24/2008 18:19'!print: anObject on: aStream	aStream nextPutAll: self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993154 pm'!!String methodsFor: '*grease-core' stamp: 'jf 12/17/2009 10:49'!excerpt: aString radius: anInteger ellipsis: anEllipsisString	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."	| index start stop |	(index := self indexOfSubCollection: aString) = 0		ifTrue: [ ^ nil ].	start := index - anInteger max: 1.	stop := index + anInteger + aString size - 1 min: self size.	^ (start > 1 ifTrue: [ anEllipsisString ] ifFalse: [ '' ]) ,		(self copyFrom: start to: stop) ,	  	(stop < self size ifTrue: [ anEllipsisString ] ifFalse: [ '' ])! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993274 pm'!!Character methodsFor: '*grease-core' stamp: 'lr 7/24/2008 18:20'!print: anObject on: aStream	aStream nextPut: self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993379 pm'!!UndefinedObject methodsFor: '*grease-core' stamp: 'lr 2/7/2008 13:13'!print: anObject on: aStream! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.99348 pm'!!Integer methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:04'!greaseInteger	^ self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993585 pm'!!Integer methodsFor: '*grease-core' stamp: 'jf 9/30/2009 00:37'!pluralize: aSingularString 	^ self 		pluralize: aSingularString		with: (GRInflector pluralize: aSingularString)! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993676 pm'!!Integer methodsFor: '*grease-core' stamp: 'lr 1/30/2008 22:39'!pluralize: aSingularString with: aPluralString	^ self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.99377 pm'!!Object methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:02'!greaseDeprecatedApi: apiString details: detailsString 	GRDeprecatedApiNotification new		details: detailsString;		signal: apiString! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:23:02.993904 pm'!!Number methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:04'!greaseInteger	"Answer an integer of the receiver, in our case we simply truncate the number."	^ self truncated! !