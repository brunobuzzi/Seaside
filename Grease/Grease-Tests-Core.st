TestCase subclass: #GRCountingStreamTest	instanceVariableNames: 'countingStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRPrinterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRPackageTest	instanceVariableNames: 'package'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRCollectionTest subclass: #GRAbstractDictionaryTest	instanceVariableNames: 'associations'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractDictionaryTest subclass: #GRIdentityDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRNumberTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRNotification subclass: #GRNotificationStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRError subclass: #GRErrorStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRExceptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRUtf8CodecTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRDelayedSendTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRCollectionTest subclass: #GRAbstractSequenceableCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GRArrayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GRSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GRSortedCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GRIntervalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRCollectionTest subclass: #GRSetTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRPlatformTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractDictionaryTest subclass: #GRDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRCollectionTest subclass: #GRBagTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRObject subclass: #GRObjectStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRCodecTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GRStringTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRNullCodecStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRVersionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRAbstractSequenceableCollectionTest subclass: #GROrderedCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRDurationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRSmallDictionaryTest	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!GRSmallDictionaryTest subclass: #GROrderedMultiMapTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!TestCase subclass: #GRCodecTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRCodecTest methodsFor: 'private' stamp: 'lr 7/25/2011 19:50'!asString: aCollectionOfIntegers	^ String streamContents: [ :stream |		aCollectionOfIntegers do: [ :each |			stream nextPut: (Character codePoint: each) ] ]! !!GRCodecTest methodsFor: 'private' stamp: 'pmm 2/17/2010 20:01'!seasideByteArray	^ #(83 101 97 115 105 100 101) "Seaside" asByteArray! !!GRCodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:24'!latin1String	^ self asString: #(220 98 232 114 115 116 114 238 241 103 233)! !!GRCodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:24'!utf16leString	^ self asString: #(220 0 98 0 232 0 114 0 115 0 116 0 114 0 238 0 241 0 103 0 233 0)! !!GRCodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:24'!macromanString	^ self asString: #(134 98 143 114 115 116 114 148 150 103 142)! !!GRCodecTest methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:50'!decodedString	^ 'Übèrstrîñgé'! !!GRCodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:24'!utf16beString	^ self asString: #(0 220 0 98 0 232 0 114 0 115 0 116 0 114 0 238 0 241 0 103 0 233)! !!GRCodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:24'!utf8String	^ self asString: #(195 156 98 195 168 114 115 116 114 195 174 195 177 103 195 169)! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 11/17/2010 21:41'!testAllCodecs	self assert: GRCodec allCodecs notEmpty.	GRCodec allCodecs do: [ :codec | 		self deny: codec class = GRCodec.		self assert: (codec isKindOf: GRCodec) ]! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 5/27/2010 22:55'!testCodecLatin1	#('iso-8859-1' 'ISO-8859-1' ) do:  [ :each | 		| codec |		codec := GRCodec forEncoding: each.		self assert: codec name = each.		self assert: codec url name = each.				"Dialects may not guarantee anything about the comparability of		 encoded strings.  Convert to Strings for simplicity."		self assert: (codec encode: self decodedString) greaseString = self latin1String greaseString.		self assert: (codec url encode: self decodedString) greaseString = self latin1String greaseString.		self assert: (codec decode: self latin1String) = self decodedString.		self assert: (codec url decode: self latin1String) = self decodedString ]! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:19'!testNullCodec	| codec strings |	codec := GRNullCodec new.	strings := OrderedCollection new		add: self latin1String;		add: self utf8String;		add: self utf16leString;		add: self utf16beString;		add: self macromanString;		yourself.	strings do:  [ :string | 		self assert: (codec encode: string) = string.		self assert: (codec url encode: string) = string.		self assert: (codec decode: string) = string.		self assert: (codec url decode: string) = string ]! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 11/17/2010 22:09'!testCodecLatin1BorderLineString	#('iso-8859-1' 'ISO-8859-1' ) do:  [ :each | 		| codec writeStream |		codec := GRCodec forEncoding: each.		writeStream := codec encoderFor: GRPlatform current readWriteCharacterStream.		writeStream nextPut: (Character codePoint: 0).		writeStream nextPut: (Character codePoint: 255).		self assert: writeStream contents = (String with: (Character codePoint: 0) with: (Character codePoint: 255)) ]! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 8/26/2011 09:38'!testReset	| contents |	contents := String streamContents: [ :s |		| stream |		stream := (GRCodec forEncoding: 'ISO-8859-1') encoderFor: s.		stream			nextPutAll: 'abc';			reset;			nextPut: $d ].	self assert: contents = 'd'! !!GRCodecTest methodsFor: 'tests' stamp: 'pmm 2/17/2010 20:06'!testNext	#('iso-8859-1' 'ISO-8859-1' ) do:  [ :each | 		| stream |		stream := (GRCodec forEncoding: each)			encoderFor: self seasideByteArray readStream.		self assert: stream next = $S.		self assert: (stream next: 1) = 'e' ]! !TestCase subclass: #GRCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRCollectionTest methodsFor: 'asserting' stamp: 'jf 2/9/2010 11:57'!assert: aCollection sortedWith: sortBlock	"Assert that aCollection is correctly sorted according to sortBlock."	1 to: aCollection size -1 do: [ :index |		| a b |		a := aCollection at: index.		b := aCollection at: index + 1.		self assert: ((sortBlock value: a value: b) or: [ (sortBlock value: b value: a) not ]) ]! !!GRCollectionTest methodsFor: 'asserting' stamp: 'jf 2/9/2010 11:56'!assert: responseCollection validSequencedNewResponseFrom: receiverCollection	"Assert that the returned object is, in fact a new object, and that it is	of a valid response class for the tested collection."		self deny: responseCollection == receiverCollection.	self assert: (self isValidNewSequencedResponseClass: responseCollection class)! !!GRCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:20'!testSorted	| sorted collection |	collection := self arbitraryCollection.	sorted := collection sorted.	self assert: sorted validSequencedNewResponseFrom: collection.	self assert: sorted sortedWith: [ :a :b | a <= b ].		sorted := collection sorted: [ :a :b | a > b ].	self assert: sorted validSequencedNewResponseFrom: collection.	self assert: sorted sortedWith: [ :a :b | a > b ]! !!GRCollectionTest methodsFor: 'tests' stamp: 'jf 2/15/2010 23:05'!testIsCollection	self assert: self arbitraryCollection isCollection! !!GRCollectionTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:34'!testNoneSatisfy	| excluded included |	excluded := self excludedElement.	self assert: (self arbitraryCollection noneSatisfy: [ :each | each = excluded ]).	included := self includedElement.	self deny: (self arbitraryCollection noneSatisfy: [ :each | each = included ]).	self assert: (self emptyCollection noneSatisfy: [ :each | true ])! !!GRCollectionTest methodsFor: 'tests' stamp: 'jf 2/6/2010 02:05'!testEmptyAny	| collection |	collection := self emptyCollection.		self should: [ (self valuesOf: collection) includes: collection any ] raise: Error! !!GRCollectionTest methodsFor: 'tests' stamp: 'jf 2/6/2010 01:54'!testAny	| collection |	collection := self arbitraryCollection.		self assert: ((self valuesOf: collection) includes: collection any)! !!GRCollectionTest methodsFor: 'tests' stamp: 'jf 2/6/2010 02:08'!testNotEmpty		self assert: self arbitraryCollection notEmpty.	self deny:  self emptyCollection notEmpty.	self assert: self arbitraryCollection notEmpty.	self deny:  self emptyCollection notEmpty! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jf 2/9/2010 12:00'!emptyCollection	"Answer an empty collection."	^ self collectionClass new! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jf 2/9/2010 11:59'!collectionClass	"Answer the collection class that is being tested."	self subclassResponsibility! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jok 3/25/2010 11:59'!duplicateElement	"Answer an element that appears multiple times in #arbitraryCollection."	^ 3! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jf 2/9/2010 12:01'!includedElement	"Answer a (non-duplicate) element that does appear in #arbitraryCollection."	^ 2! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jf 2/9/2010 11:58'!allowsDuplicateValues	"Does the tested collection allow storage of duplicate (equal) values."	self subclassResponsibility! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jf 2/9/2010 12:01'!excludedElement	"Answer an element that does not appear in #arbitraryCollection."	^ 19! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jok 3/25/2010 15:21'!arbitraryCollection	"An general collection for testing. It should meet the needs of #duplicateElement,	#excludedElement, #includedElement, and so on where appropriate.  Make sure the	duplicated element doesn't end up being in the first or last position both before	and after sorting."		^ self collectionClass withAll: #(4 3 1 2 3 5)! !!GRCollectionTest methodsFor: 'configuration' stamp: 'jok 3/29/2010 12:24'!isValidNewSequencedResponseClass: aClass	"Answer whether aClass is a valid return type for methods that return a new sequenced	collection. These are methods such as #copyFrom:to: or #reverse, which are	defined by ANSI for most classes to return the same class as the receiver.	However, for Interval (and maybe other cases), ANSI specifies that the response	may be any <sequencedReadableCollection>."		^ aClass == self collectionClass or: [		aClass allSuperclasses includes: SequenceableCollection ]! !!GRCollectionTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:10'!isExtensible	"Answer whether the tested Collection implements the <extensibleCollection>	protocol as defined in ANSI 5.7.5	."			self subclassResponsibility! !!GRCollectionTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	"Answer whether the tested Collection implements the <initializableCollection factory>	protocol as defined in ANSI 5.7.23."		self subclassResponsibility! !!GRCollectionTest methodsFor: 'private' stamp: 'jf 2/9/2010 12:02'!valuesOf: aCollection	"Answer the values of aCollecion. Dictionary tests override this."		^ aCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRCollectionTest class	instanceVariableNames: ''!!GRCollectionTest class methodsFor: 'testing' stamp: 'jf 2/6/2010 01:52'!isAbstract	^ self name = #GRCollectionTest! !GRCollectionTest subclass: #GRAbstractDictionaryTest	instanceVariableNames: 'associations'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRAbstractDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:05'!isKey: anObject equivalentTo: anotherObject	self subclassResponsibility! !!GRAbstractDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ true! !!GRAbstractDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:42'!arbitraryAssociations	^ associations ifNil: [ associations := self createArbitraryAssociations ]! !!GRAbstractDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:08'!arbitraryCollection	| dict |	dict := self emptyCollection.	self arbitraryAssociations do: [ :each |		dict at: each key put: each value ].	^ dict! !!GRAbstractDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:41'!createArbitraryAssociations	self subclassResponsibility! !!GRAbstractDictionaryTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:34'!testAssociationsDo	| collection assocs count |	collection := self arbitraryCollection.	assocs := self arbitraryAssociations copy.	count := 0.	collection associationsDo: [ :assoc |		| size |		count := count + 1.		size := assocs size.		assocs := assocs			reject: [ :each |				(self isKey: each key equivalentTo: assoc key)					and: [ each value = assoc value ] ].		self assert: size - 1 = assocs size ].	self assert: assocs isEmpty.	self assert: count = self arbitraryAssociations size! !!GRAbstractDictionaryTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:35'!isExtensible	^ false! !!GRAbstractDictionaryTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:29'!isInitializable	^ false! !!GRAbstractDictionaryTest methodsFor: 'private' stamp: 'jf 2/6/2010 01:58'!valuesOf: aCollection	^ aCollection values! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRAbstractDictionaryTest class	instanceVariableNames: ''!!GRAbstractDictionaryTest class methodsFor: 'testing' stamp: 'jf 2/15/2010 22:01'!isAbstract	^ self name = #GRAbstractDictionaryTest! !GRCollectionTest subclass: #GRAbstractSequenceableCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRAbstractSequenceableCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:02'!isUnique	"Some classes cannot be copied because they represent unique values.  Symbol is an example of such a class."	^ self subclassResponsibility! !!GRAbstractSequenceableCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:20'!isHomogeneous	"Some classes can contain only objects of a particular class.  String is an example of such a class."	^ self subclassResponsibility! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:20'!testEndsWithEmptySubCollection	| collection | 	collection := self arbitraryCollection.	self deny: (collection endsWithSubCollection: self emptyCollection).	self deny: (self emptyCollection endsWithSubCollection: collection)! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:28'!testCopyAfterLast	| collection sub |		"match first element"	collection := self arbitraryCollection.	sub := collection copyAfterLast: collection last.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub isEmpty.		"no match"	self isUnique ifFalse: [		sub := collection copyAfter: self excludedElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub isEmpty ].		"match an element"	sub := collection copyAfterLast: self includedElement.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub = (collection copyFrom: collection size - sub size + 1 to: collection size).	self assert: (collection at: collection size - sub size) = self includedElement.	self allowsDuplicateValues ifTrue: [		sub := collection copyAfterLast: self duplicateElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub = (collection copyFrom: collection size - sub size + 1 to: collection size).		self assert: (collection at: collection size - sub size) = self duplicateElement.		self deny: (sub includes: self duplicateElement) ].		"Make sure we're using equality"	(self isHomogeneous not and: [ self isInitializable ]) ifTrue: [		collection := self collectionClass withAll: #(1 '1').		sub := collection copyAfterLast: 1.		self assert: sub size = 1.		self assert: (sub at: 1) = '1' ]! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 1/22/2012 16:30'!testCopyUpTo	| collection sub |		"match first element"	collection := self arbitraryCollection.	sub := collection copyUpTo: (collection at: 1).	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub isEmpty.		"no match"	self isUnique ifFalse: [		sub := collection copyUpTo: self excludedElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub size = collection size.		collection keysAndValuesDo: [ :index :value |			self assert: (sub at: index) = value ] ].		"match an element"	sub := collection copyUpTo: self includedElement.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub = (collection copyFrom: 1 to: sub size).	self assert: (collection at: sub size + 1) = self includedElement.	self allowsDuplicateValues ifTrue: [		sub := collection copyUpTo: self duplicateElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub = (collection copyFrom: 1 to: sub size).		self assert: (collection at: sub size + 1) = self duplicateElement.		self deny: (sub includes: self duplicateElement) ].		"Make sure we're using equality"	(self isHomogeneous not and: [ self isInitializable ]) ifTrue: [		collection := self collectionClass withAll: #(1 '1').		sub := collection copyUpTo: '1'.		self assert: sub size = 1.		self assert: (sub at: 1) = 1 ]! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:34'!testCopyUpToLast	| collection sub |		"match first element"	collection := self arbitraryCollection.	sub := collection copyUpToLast: collection first.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub isEmpty.		"no match"	self isUnique ifFalse: [		sub := collection copyUpToLast: self excludedElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub size = collection size.		collection keysAndValuesDo: [ :index :value |			self assert: (sub at: index) = value ] ].		"match an element"	sub := collection copyUpToLast: self includedElement.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub = (collection copyFrom: 1 to: sub size).	self assert: (collection at: sub size + 1) = self includedElement.	self allowsDuplicateValues ifTrue: [		sub := collection copyUpToLast: self duplicateElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub = (collection copyFrom: 1 to: sub size).		self assert: (collection at: sub size + 1) = self duplicateElement.		self assert: (sub includes: self duplicateElement) ].		"Make sure we're using equality"	(self isHomogeneous not and: [ self isInitializable ]) ifTrue: [		collection := self collectionClass withAll: #(1 '1').		sub := collection copyUpToLast: '1'.		self assert: sub size = 1.		self assert: sub first = 1 ]! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:20'!testEndsWithSubCollection	| collection |	collection := self arbitraryCollection.	self assert: (collection endsWithSubCollection: (collection copyWithout: collection first)).	self assert: (collection endsWithSubCollection: collection).	self deny: (collection endsWithSubCollection: (collection copyWith: collection first))! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:28'!testCopyAfter	| collection sub |		"match last element"	collection := self arbitraryCollection.	sub := collection copyAfter: collection last.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub isEmpty.		"no match"	self isUnique ifFalse: [		sub := collection copyAfter: self excludedElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub isEmpty ].		"match an element"	sub := collection copyAfter: self includedElement.	self assert: sub validSequencedNewResponseFrom: collection.	self assert: sub = (collection copyFrom: collection size - sub size + 1 to: collection size).	self assert: (collection at: collection size - sub size) = self includedElement.	self allowsDuplicateValues ifTrue: [		sub := collection copyAfter: self duplicateElement.		self assert: sub validSequencedNewResponseFrom: collection.		self assert: sub = (collection copyFrom: collection size - sub size + 1 to: collection size).		self assert: (collection at: collection size - sub size) = self duplicateElement.		self assert: (sub includes: self duplicateElement) ].		"Make sure we're using equality"	(self isHomogeneous not and: [ self isInitializable ]) ifTrue: [		collection := self collectionClass withAll: #(1 '1').		sub := collection copyAfter: 1.		self assert: sub size = 1.		self assert: (sub at: 1) = '1' ]! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:21'!testBeginsWithEmptySubCollection	| collection | 	collection := self arbitraryCollection.	self deny: (collection beginsWithSubCollection: self emptyCollection).	self deny: (self emptyCollection beginsWithSubCollection: collection)! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:24'!testAddFirst	| collection |	(self isExtensible and: [ self isSequenced ]) ifFalse: [ ^ self ].		collection := self arbitraryCollection.	collection addFirst: self excludedElement.	self assert: (collection at: 1) = self excludedElement.	self assert: (collection copyFrom: 2 to: collection size) = self arbitraryCollection! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:20'!testBeginsWithSubCollection	| collection |	collection := self arbitraryCollection.	self assert: (collection beginsWithSubCollection: (collection copyWithout: collection last)).	self assert: (collection beginsWithSubCollection: collection).	self deny: (collection beginsWithSubCollection: (collection copyWith: collection first))! !!GRAbstractSequenceableCollectionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:20'!testSort	| collection |	self isSequenced ifFalse: [ ^ self ].		collection := self arbitraryCollection.	collection sort.	self assert: collection sortedWith: [ :a :b | a <= b ].		collection sort: [ :a :b | a > b ].	self assert: collection sortedWith: [ :a :b | a > b ]! !!GRAbstractSequenceableCollectionTest methodsFor: 'testing-ansi' stamp: 'jok 3/29/2010 12:54'!isSequenced	"Answer whether the tested Collection implements the <sequencedCollection>	protocol as defined in ANSI 5.7.12."		self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRAbstractSequenceableCollectionTest class	instanceVariableNames: ''!!GRAbstractSequenceableCollectionTest class methodsFor: 'testing' stamp: 'jok 3/26/2010 17:21'!isAbstract	^ self name = #GRAbstractSequenceableCollectionTest! !GRAbstractSequenceableCollectionTest subclass: #GRArrayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRArrayTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 04:03'!isSequenced	^ true! !!GRArrayTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:34'!isExtensible	^ false! !!GRArrayTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	^ true! !!GRArrayTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:02'!isUnique	^ false! !!GRArrayTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:22'!isHomogeneous	^ false! !!GRArrayTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 01:51'!collectionClass	^ Array! !!GRArrayTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ true! !GRCollectionTest subclass: #GRBagTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRBagTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 01:51'!collectionClass	^ Bag! !!GRBagTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ true! !!GRBagTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:34'!isExtensible	^ true! !!GRBagTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	^ true! !TestCase subclass: #GRCountingStreamTest	instanceVariableNames: 'countingStream'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRCountingStreamTest methodsFor: 'running' stamp: 'pmm 7/16/2015 16:32'!setUp	| codecStream |	codecStream := ((GRCodec forEncoding: 'utf-8') encoderFor: (WriteStream on: String new)).	countingStream := GRCountingStream on: codecStream! !!GRCountingStreamTest methodsFor: 'testing' stamp: 'pmm 8/19/2014 09:29'!testNextPutAll	countingStream nextPutAll: (String with: (Character codePoint: 16rE4)).	self assert: countingStream size = 2.	self assert: countingStream count = 1.	self assert: countingStream contents = (String with:  (Character codePoint: 16rC3) with:  (Character codePoint: 16rA4))! !!GRCountingStreamTest methodsFor: 'testing' stamp: 'pmm 6/25/2012 20:51'!testInitialSize	self assert: countingStream count = 0! !!GRCountingStreamTest methodsFor: 'testing' stamp: 'pmm 6/25/2012 20:51'!testReset	countingStream nextPut: $a.	self assert: countingStream count = 1.	countingStream reset.	self assert: countingStream count = 0! !!GRCountingStreamTest methodsFor: 'testing' stamp: 'pmm 8/19/2014 09:29'!testNextPut	countingStream nextPut: (Character codePoint: 16rE4).	self assert: countingStream size = 2.	self assert: countingStream count = 1.	self assert: countingStream contents = (String with:  (Character codePoint: 16rC3) with:  (Character codePoint: 16rA4))! !TestCase subclass: #GRDelayedSendTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueValueKeyword	| send |	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self deny: (send 			value: 2			value: 3).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self 		should: 			[ send 				value: 4				value: 5 ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self 		should: 			[ send 				value: 4				value: 5 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentBinary	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self assert: (send value: 2) = 3.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self 		should: [ send value: 2 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithPossibleArgumentsBinary	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self 		should: [ send valueWithPossibleArguments: #() ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: (send valueWithPossibleArguments: #()) = 3.	send := GRDelayedSend 		receiver: 1		selector: #+.	self assert: (send valueWithPossibleArguments: #(2 )) = 3.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: (send valueWithPossibleArguments: #(3 )) = 3.	send := GRDelayedSend 		receiver: 1		selector: #+.	self assert: (send valueWithPossibleArguments: #(2 3 )) = 3.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: (send valueWithPossibleArguments: #(3 4 )) = 3! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithPossibleArgumentsKeyword	| send |	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self 		should: [ send valueWithPossibleArguments: #() ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self 		should: [ send valueWithPossibleArguments: #() ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self deny: (send valueWithPossibleArguments: #()).	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self 		should: [ send valueWithPossibleArguments: #(2 ) ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self deny: (send valueWithPossibleArguments: #(3 )).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self deny: (send valueWithPossibleArguments: #(4 )).	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self deny: (send valueWithPossibleArguments: #(2 3 )).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self deny: (send valueWithPossibleArguments: #(3 4 )).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self deny: (send valueWithPossibleArguments: #(4 5 ))! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentUnary	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self 		should: [ send value: 2 ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self 		should: [ send value: 2 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentsUnary	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self 		should: [ send valueWithArguments: #(2 3 ) ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self 		should: [ send valueWithArguments: #(2 3 ) ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueBinary	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self 		should: [ send value ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: send value = 3! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueValueUnary	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self 		should: 			[ send 				value: 2				value: 3 ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self 		should: 			[ send 				value: 2				value: 3 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueKeyword	| send |	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self 		should: [ send value ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self 		should: [ send value ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self deny: send value! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueValueBinary	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self 		should: 			[ send 				value: 2				value: 3 ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self 		should: 			[ send 				value: 2				value: 3 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:22'!testValueWithPossibleArgumentsUnary	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self assert: (send valueWithPossibleArguments: #()) = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self assert: (send valueWithPossibleArguments: #()) = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated.	self assert: (send valueWithPossibleArguments: #(2 )) = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self assert: (send valueWithPossibleArguments: #(2 )) = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated.	self assert: (send valueWithPossibleArguments: #(2 3 )) = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self assert: (send valueWithPossibleArguments: #(2 3 )) = -1! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentKeyword	| send |	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self 		should: [ send value: 2 ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self deny: (send value: 3).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: #(2 3 ).	self 		should: [ send value: 4 ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:22'!testValueUnary	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self assert: send value = -1.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self assert: send value = -1! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:22'!testFixCallbackTemps	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self assert: send fixCallbackTemps == send.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: send fixCallbackTemps == send! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentsKeyword	| send |	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self deny: (send valueWithArguments: #(2 3 )).	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self 		should: [ send valueWithArguments: #(3 4 ) ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: #(2 3 ).	self 		should: [ send valueWithArguments: #(4 5 ) ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-evaluating' stamp: 'jf 9/30/2009 00:24'!testValueWithArgumentsBinary	| send |	send := GRDelayedSend 		receiver: 1		selector: #+.	self 		should: [ send valueWithArguments: #(2 3 ) ]		raise: GRInvalidArgumentCount.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self 		should: [ send valueWithArguments: #(3 4 ) ]		raise: GRInvalidArgumentCount! !!GRDelayedSendTest methodsFor: 'tests-accessing' stamp: 'jf 9/30/2009 00:22'!testArgumentCount	" unary "	| send |	send := GRDelayedSend 		receiver: 1		selector: #negated.	self assert: send argumentCount = 0.	send := GRDelayedSend 		receiver: 1		selector: #negated		arguments: #().	self assert: send argumentCount = 0.	" binary "	send := GRDelayedSend 		receiver: 1		selector: #+.	self assert: send argumentCount = 1.	send := GRDelayedSend 		receiver: 1		selector: #+		argument: 2.	self assert: send argumentCount = 0.	" keyword "	send := GRDelayedSend 		receiver: 1		selector: #between:and:.	self assert: send argumentCount = 2.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		argument: 2.	self assert: send argumentCount = 1.	send := GRDelayedSend 		receiver: 1		selector: #between:and:		arguments: (Array 				with: 2				with: 3).	self assert: send argumentCount = 0! !GRAbstractDictionaryTest subclass: #GRDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:06'!isKey: anObject equivalentTo: anotherObject	^ anObject = anotherObject! !!GRDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:00'!collectionClass	^ Dictionary! !!GRDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:41'!createArbitraryAssociations	^ OrderedCollection new		add: #c -> 3;		add: #a -> 1;		add: #b -> 2;		add: #e -> 1;		add: #d -> 4;		yourself! !TestCase subclass: #GRDurationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:25'!testPartialSecondsInstanceCreation	"ANSI 5.8.3.1 and 5.8.3.2 specify that the seconds argument can be any	Number - not just an integer as is the case for the other arguments."	self assert: (Duration days: 0 hours: 0 minutes: 0 seconds: 1.5) asMilliseconds = 1500.	self assert: (Duration days: 0 hours: 0 minutes: 0 seconds: 3/2) asMilliseconds = 1500.	self assert: (Duration seconds: 1.5) asMilliseconds = 1500.	self assert: (Duration seconds: 3/2) asMilliseconds = 1500! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:29'!testRolloverInstanceCreation	self assert: (Duration days: 0 hours: 25 minutes: 61 seconds: 61) asMilliseconds = 93721000.	self assert: (Duration hours: 25) asMilliseconds = 90000000.	self assert: (Duration minutes: 61) asMilliseconds = 3660000.	self assert: (Duration seconds: 61) asMilliseconds = 61000.	self assert: (Duration milliseconds: 1001) asMilliseconds = 1001! !!GRDurationTest methodsFor: 'tests' stamp: 'jf 2/5/2010 23:47'!testZero	| duration |	duration := Duration zero.	self assert: duration isZero.	self assert: duration asMilliseconds = 0.	self assert: duration = (Duration seconds: 0)! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:26'!testMixedInstanceCreation	self assert: (Duration days: 1 hours: -23 minutes: 1 seconds: -59) asMilliseconds = 3601000! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:26'!testAccessors	| duration |	duration := Duration seconds: 356521.	self assert: duration days = 4.	self assert: duration hours = 3.	self assert: duration minutes = 2.	self assert: duration seconds = 1.	self assert: duration milliseconds = 0! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:25'!testConversions	| duration |	duration := Duration days: 4 hours: 3 minutes: 2 seconds: 1.	self assert: duration asSeconds = 356521.	self assert: duration asMilliseconds = 356521000.	self assert: duration negated asSeconds = -356521.	self assert: duration negated asMilliseconds = -356521000	! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:29'!testBasicInstanceCreation	self assert: (Duration days: 1 hours: 1 minutes: 1 seconds: 1) asMilliseconds = 90061000.	self assert: (Duration weeks: 1) asMilliseconds = 604800000.	self assert: (Duration days: 1) asMilliseconds = 86400000.	self assert: (Duration hours: 1) asMilliseconds = 3600000.	self assert: (Duration minutes: 1) asMilliseconds = 60000.	self assert: (Duration seconds: 1) asMilliseconds = 1000.	self assert: (Duration milliseconds: 1) asMilliseconds = 1! !!GRDurationTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:26'!testNegativeInstanceCreation	self assert: (Duration days: -1 hours: -1 minutes: -1 seconds: -1) asMilliseconds = -90061000.	self assert: (Duration weeks: -1) asMilliseconds = -604800000.	self assert: (Duration days: -1) asMilliseconds = -86400000.	self assert: (Duration hours: -1) asMilliseconds = -3600000.	self assert: (Duration minutes: -1) asMilliseconds = -60000.	self assert: (Duration seconds: -1) asMilliseconds = -1000.	self assert: (Duration milliseconds: -1) asMilliseconds = -1! !!GRDurationTest methodsFor: 'testing' stamp: 'pmm 9/1/2012 15:25'!testIntegerConvenienceMethods	self assert: 5 weeks = (Duration weeks: 5).	self assert: 5 days = (Duration days: 5).	self assert: 5 hours = (Duration hours: 5).	self assert: 5 minutes = (Duration minutes: 5).	self assert: 5 seconds = (Duration seconds: 5).	self assert: 5 milliseconds = (Duration milliseconds: 5)! !GRError subclass: #GRErrorStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRErrorStub methodsFor: 'initialization' stamp: 'jf 3/13/2009 16:56'!initialize	super initialize.	foo := true! !!GRErrorStub methodsFor: 'accessing' stamp: 'jf 3/13/2009 16:56'!foo	^ foo! !TestCase subclass: #GRExceptionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRExceptionTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:57'!testNotificationInitialization	"Make sure #initialize is called on #new and that calling 'super initialize' doesn't error."	self assert: GRNotificationStub new foo! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:02'!testSignalWithErrorClassSide	"Exception class>>signal: is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	| text |	text := 'Error!!'.	[ GRError signal: text ] 		on: GRError		do: 			[ :e | 			self assert: e messageText = text.			^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:02'!testSignalErrorClassSide	"Exception class>>signal is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	[ GRError signal ] 		on: GRError		do: [ :e | ^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:03'!testSignalNotification	"Exception>>signal is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	[ GRNotification new signal ] 		on: GRNotification		do: [ :e | ^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:31'!testOnDoImplicitReturn	"According to ANSI 5.5.15.2, an exception handler block that runs to completion	should result in the call to #on:do: returning the block's value."		| result |	result := [ GRErrorStub signal ] on: GRErrorStub do: [ :e | #blockValue ].	self assert: result = #blockValue.		result := nil.	result := [ GRNotificationStub signal ] on: GRNotificationStub do: [ :e | #blockValue ].	self assert: result = #blockValue! !!GRExceptionTest methodsFor: 'tests' stamp: 'jf 11/3/2009 00:39'!testIsResumable	"Make sure the platform class provides #isResumable on Exception.	This test made a bit more complex by James Foster per issue #259	for GemStone portability."	| exception |	[ Exception signal ]		on: Exception		do: [ :ex | 			exception := ex.			ex return	].	self shouldnt: [ exception isResumable ] raise: MessageNotUnderstood! !!GRExceptionTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:56'!testErrorInitialization	"Make sure #initialize is called on #new and that calling 'super initialize' doesn't error."	self assert: GRErrorStub new foo! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:02'!testSignalNotificationClassSide	"Exception class>>signal is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	[ GRNotification signal ] 		on: GRNotification		do: [ :e | ^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:02'!testSignalWithNotification	"Exception>>signal: is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	| text |	text := 'Notification'.	[ GRNotification new signal: text ] 		on: GRNotification		do: 			[ :e | 			self assert: e messageText = text.			^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:01'!testSignalError	"Exception>>signal is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	[ GRError new signal ] 		on: GRError		do: [ :e | ^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:31'!testDefaultActionResume	"According to ANSI 5.5.15.2, the result of #defaultAction	should be used to resume resumable exceptions. Behaviour is undefined	for non-resumable exceptions so we do not test for that case."		| result |	result := GRNotificationStub signal.	self assert: result = #returnValue! !!GRExceptionTest methodsFor: 'tests' stamp: 'jf 11/3/2009 00:53'!testOnDoNonLocalReturn	"You should be able to do a non-local return from within an exception	handler block. We rely on a helper method here so we can check the return	value."		self assert: (self onExceptionReturn: 123) == 123! !!GRExceptionTest methodsFor: 'tests' stamp: 'lr 1/25/2010 23:31'!testDeprecatedApi	| exception seen |	exception := seen := nil.		[ self 		greaseDeprecatedApi: 'GRExceptionTest>>#testDeprecatedApi'		details: 'Message in a bottle.'.	seen := true ] 		on: GRDeprecatedApiNotification		do: 			[ :notification | 			exception := notification.			exception resume.			seen := false ].	self assert: seen.	self assert: exception notNil.	self assert: exception messageText = 'GRExceptionTest>>#testDeprecatedApi'.	self assert: exception details = 'Message in a bottle.'! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:03'!testSignalWithNotificationClassSide	"Exception class>>signal: is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	| text |	text := 'Notification'.	[ GRNotification signal: text ] 		on: GRNotification		do: 			[ :e | 			self assert: e messageText = text.			^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:02'!testSignalWithError	"Exception>>signal: is part of the ANSI Smalltalk standard. However, Seaside	only signals subclasses of GRError and GRNotification so Smalltalk	implementations that do not otherwise provide it can implement it on	these two classes."	| text |	text := 'Error!!'.	[ GRError new signal: text ] 		on: GRError		do: 			[ :e | 			self assert: e messageText = text.			^ self ].	self assert: false! !!GRExceptionTest methodsFor: 'private' stamp: 'lr 7/25/2011 18:34'!onExceptionReturn: anObject	[ GRError signal ]		on: GRError		do: [ :ex | ^ anObject ].		^ self! !GRAbstractDictionaryTest subclass: #GRIdentityDictionaryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRIdentityDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:06'!isKey: anObject equivalentTo: anotherObject	^ anObject == anotherObject! !!GRIdentityDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 21:57'!collectionClass	^ IdentityDictionary! !!GRIdentityDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:43'!createArbitraryAssociations	^ OrderedCollection new		add: 'c' -> 3;		add: 'a' -> 1;		add: 'b' -> 2;		add: 'd' -> 1;		add: 'b' copy -> 4;		yourself! !GRAbstractSequenceableCollectionTest subclass: #GRIntervalTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRIntervalTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:03'!isUnique	^ false! !!GRIntervalTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:22'!isHomogeneous	^ true! !!GRIntervalTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:24'!testEndsWithSubCollection	self assert: ((-5 to: 10 by: 3) endsWithSubCollection: (-2 to: 10 by: 3)).	self assert: ((-5 to: 10 by: 3) endsWithSubCollection: (-5 to: 10 by: 3)).	self deny: ((-5 to: 10 by: 3) endsWithSubCollection: (-5 to: 13 by: 3))! !!GRIntervalTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:24'!testBeginsWithSubCollection	self assert: ((-5 to: 10 by: 3) beginsWithSubCollection: (-5 to: 7 by: 3)).	self assert: ((-5 to: 10 by: 3) beginsWithSubCollection: (-5 to: 10 by: 3)).	self deny: ((-5 to: 10 by: 3) beginsWithSubCollection: (-8 to: 10 by: 3))! !!GRIntervalTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 04:03'!isSequenced	^ false! !!GRIntervalTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:35'!isExtensible	^ false! !!GRIntervalTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:29'!isInitializable	^ false! !!GRIntervalTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:49'!arbitraryCollection	^ 1 to: 4! !!GRIntervalTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:50'!emptyCollection	^ 1 to: 0! !!GRIntervalTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:48'!collectionClass	^ Interval! !!GRIntervalTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ false! !GRNotification subclass: #GRNotificationStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRNotificationStub methodsFor: 'accessing' stamp: 'jf 3/13/2009 16:56'!foo	^ foo! !!GRNotificationStub methodsFor: 'accessing' stamp: 'jf 11/3/2009 00:45'!defaultAction	^ #returnValue! !!GRNotificationStub methodsFor: 'initialization' stamp: 'jf 3/13/2009 16:56'!initialize	super initialize.	foo := true! !TestCase subclass: #GRNullCodecStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRNullCodecStreamTest methodsFor: 'tests' stamp: 'dkh 11/13/2009 15:36'!testWriteString	| stream codecStream |	stream := WriteStream on: String new.	codecStream := GRNullCodec new encoderFor: stream.	codecStream		nextPut: $A;		nextPutAll: 'BC';		nextPut: 68;		nextPutAll: #(69 70 ) asByteArray.	self assert: codecStream contents = 'ABCDEF'! !!GRNullCodecStreamTest methodsFor: 'tests' stamp: 'dkh 11/13/2009 15:36'!testReadString	| stream codecStream |	stream := 'abc' readStream.	codecStream := GRNullCodec new decoderFor: stream.	self assert: codecStream next = $a.	self assert: (codecStream next: 2) = 'bc'! !!GRNullCodecStreamTest methodsFor: 'private' stamp: 'pmm 2/17/2010 20:03'!seasideByteArray	^ #(83 101 97 115 105 100 101) "Seaside" asByteArray! !!GRNullCodecStreamTest methodsFor: 'tests-characters' stamp: 'lr 2/6/2010 10:34'!testCrlf	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream crlf.		self assert: stream contents size = 2.	self assert: stream contents first = Character cr.	self assert: stream contents last = Character lf! !!GRNullCodecStreamTest methodsFor: 'tests-characters' stamp: 'pmm 5/26/2010 07:08'!testName	| codec |	codec := GRNullCodec new.		self assert: codec name = GRNullCodec codecName! !!GRNullCodecStreamTest methodsFor: 'tests-characters' stamp: 'lr 2/6/2010 10:34'!testSpace	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream space.		self assert: stream contents size = 1.	self assert: stream contents first = Character space! !!GRNullCodecStreamTest methodsFor: 'tests-characters' stamp: 'lr 2/6/2010 10:35'!testTab	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream tab.		self assert: stream contents size = 1.	self assert: stream contents first = Character tab! !!GRNullCodecStreamTest methodsFor: 'tests-protocol' stamp: 'lr 2/6/2010 10:37'!testFlush	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream nextPutAll: 'abc'.	self shouldnt: [ stream flush ] raise: Error.	self assert: stream contents = 'abc'! !!GRNullCodecStreamTest methodsFor: 'tests-protocol' stamp: 'lr 2/6/2010 10:37'!testSize	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream nextPutAll: 'abc'.	self assert: stream size = 3.	stream nextPut: $d.	self assert: stream size = 4! !!GRNullCodecStreamTest methodsFor: 'tests-protocol' stamp: 'pmm 2/17/2010 20:09'!testNext	| stream |	stream := GRNullCodec new		encoderFor: 'Seaside' readStream.	self assert: stream next = $S.	self assert: (stream next: 1) = 'e'! !!GRNullCodecStreamTest methodsFor: 'tests-protocol' stamp: 'lr 9/25/2011 10:12'!testPrint	| stream |	stream := GRNullCodec new 		encoderFor: (WriteStream on: String new).	stream print: 123.	self assert: stream contents = '123'! !!GRNullCodecStreamTest methodsFor: 'accessing' stamp: 'lr 2/6/2010 10:30'!codecStreamClass	^ GRNullCodecStream! !TestCase subclass: #GRNumberTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRNumberTest methodsFor: 'tests' stamp: 'lr 5/13/2010 12:11'!testReadFrom	"We test #readFrom: as the expected behaviour on all platforms, as we rely on it for WANumberAttribute and WAQualifiedValue"		self assert: (Number readFrom: '123' readStream) = 123.		self assert: (Float readFrom: '123.45' readStream) = 123.45.		self assert:   (Number readFrom: '123.45' readStream) = 123.45! !!GRNumberTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:31'!testTo	| collection |	collection := OrderedCollection new.	1 to: 5 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(1 2 3 4 5).		collection := OrderedCollection new.	4 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(4).		collection := OrderedCollection new.	4 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(4).		collection := OrderedCollection new.	5 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #().		collection := OrderedCollection new.	-3 to: -1.5 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(-3 -2).		collection := OrderedCollection new.	1.5 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(1.5 2.5 3.5)! !!GRNumberTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:03'!testToDoClosures	"#to:do: may be optimized and VAST currently has problems with closures	in this case. We would prefer to use the optimized version than than	(1 to: 5) do: [ ... ] so this test is here to highlight the problem at	least unless the platforms tell us the problem is not fixable."		| collection |	collection := OrderedCollection new.	1 to: 5 do: [ :each | collection add: [ each ] fixCallbackTemps ].	self assert: (collection collect: [ :each | each value ]) asArray = #(1 2 3 4 5)! !!GRNumberTest methodsFor: 'tests' stamp: 'jf 9/25/2009 16:50'!testBetweenAnd	self assert: (6 between: 1 and: 12)! !!GRNumberTest methodsFor: 'tests' stamp: 'pmm 2/24/2008 18:33'!testPluralize	self assert: (0 pluralize: 'person') = '0 people'.	self assert: (1 pluralize: 'person') = '1 person'.	self assert: (2 pluralize: 'person') = '2 people'.	self assert: (3 pluralize: 'person') = '3 people'.		self assert: (0 pluralize: 'penis') = '0 penises'.	self assert: (1 pluralize: 'penis') = '1 penis'.	self assert: (2 pluralize: 'penis') = '2 penises'.		self assert: (0 pluralize: 'person' with: 'members') = '0 members'.	self assert: (1 pluralize: 'person' with: 'members') = '1 person'.	self assert: (2 pluralize: 'person' with: 'members') = '2 members'.	self assert: (3 pluralize: 'person' with: 'members') = '3 members'! !!GRNumberTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:31'!testToDo	| collection |	collection := OrderedCollection new.	1 to: 5 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(1 2 3 4 5).		collection := OrderedCollection new.	4 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(4).		collection := OrderedCollection new.	4 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(4).		collection := OrderedCollection new.	5 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #().		collection := OrderedCollection new.	-3 to: -1.5 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(-3 -2).		collection := OrderedCollection new.	1.5 to: 4 do: [ :ea | collection add: ea ].	self assert: collection asArray = #(1.5 2.5 3.5)! !GRObject subclass: #GRObjectStub	instanceVariableNames: 'foo'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRObjectStub methodsFor: 'accessing' stamp: 'jf 2/3/2009 15:19'!foo	^ foo! !!GRObjectStub methodsFor: 'initialization' stamp: 'jf 2/3/2009 15:19'!initialize	super initialize.	foo := true! !TestCase subclass: #GRObjectTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRObjectTest methodsFor: 'tests' stamp: 'pmm 8/19/2014 10:09'!testError	"Make sure #error: signals a subclass of GRError."	self 		should: [ GRObject new error: 'oh dear' ]		raise: GRError.	self 		should: [ GRObject error: 'oh dear' ]		raise: GRError! !!GRObjectTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:56'!testInitialize	"Make sure #initialize is called on #new and that calling 'super initialize' doesn't error."	self assert: GRObjectStub new foo! !!GRObjectTest methodsFor: 'tests' stamp: 'pmm 3/29/2012 19:50'!testRespondsTo	self assert: (GRObject new respondsTo: #greaseString).	self deny: (GRObject new respondsTo: #makeMeASandwich)! !GRAbstractSequenceableCollectionTest subclass: #GROrderedCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GROrderedCollectionTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:16'!collectionClass	^ OrderedCollection! !!GROrderedCollectionTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ true! !!GROrderedCollectionTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 04:03'!isSequenced	^ true! !!GROrderedCollectionTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:34'!isExtensible	^ true! !!GROrderedCollectionTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	^ true! !!GROrderedCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:04'!isUnique	^ false! !!GROrderedCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:23'!isHomogeneous	^ false! !TestCase subclass: #GRPackageTest	instanceVariableNames: 'package'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRPackageTest methodsFor: 'tests-packages' stamp: 'JohanBrichau 12/15/2013 18:29'!testPackages	| packages |	packages := GRPackage grPackages.	self assert: packages notEmpty.	packages do: [ :each | 		self assert: each name notEmpty.		self assert: each license notNil.		self assert: each url notNil ]! !!GRPackageTest methodsFor: 'running' stamp: 'lr 2/6/2010 10:44'!setUp	super setUp.	package := GRPackage new! !!GRPackageTest methodsFor: 'tests-dependencies' stamp: 'pmm 9/1/2012 15:32'!testAllDependencies	| packages |	packages := Dictionary new.	packages 		at: 'Lust' put: (GRPackage new			name: 'Lust';			addDependency: 'Gluttony';			addDependency: 'Greed';			yourself);		at: 'Gluttony' put: (GRPackage new			name: 'Gluttony';			addDependency: 'Greed';			yourself);		at: 'Greed' put: (GRPackage new			name: 'Greed';			yourself).	packages values 		do: [ :each | each resolveWith: packages ].		self assert: (packages at: 'Lust') allDependencies size = 3.	self assert: (packages at: 'Gluttony') allDependencies size = 2.	self assert: (packages at: 'Greed') allDependencies size = 1! !!GRPackageTest methodsFor: 'tests-dependencies' stamp: 'lr 2/6/2010 10:47'!testDependencies	self assert: package dependencies isEmpty.	package addDependency: 'Lust'.	package addDependency: 'Envy'.	self assert: package dependencies size = 2.	self assert: package dependencies first = 'Lust'.	self assert: package dependencies last = 'Envy'	! !!GRPackageTest methodsFor: 'tests' stamp: 'lr 2/6/2010 10:44'!testDescription	self assert: package description isNil.	package description: 'A hopeless pacakge'.	self assert: package description = 'A hopeless pacakge'! !!GRPackageTest methodsFor: 'tests' stamp: 'lr 2/6/2010 10:44'!testName	self assert: package name isNil.	package name: 'Gimme-Hope'.	self assert: package name = 'Gimme-Hope'! !!GRPackageTest methodsFor: 'tests' stamp: 'lr 2/17/2010 15:24'!testUrl	self assert: package url isNil.		package url: #seasideLGPLUrl.	self assert: package url = GRPackage new seasideLGPLUrl. 		package url: 'http://www.seaside.st/distributions'.	self assert: package url = 'http://www.seaside.st/distributions'! !!GRPackageTest methodsFor: 'tests' stamp: 'lr 2/6/2010 10:58'!testLicense	self assert: package license = #MIT.	self assert: package isMIT.		package license: #LGPL.	self assert: package license = #LGPL.	self assert: package isLGPL! !TestCase subclass: #GRPlatformTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRPlatformTest commentStamp: 'pmm 8/19/2014 09:53' prior: 0!A GRPlatformTest is a test to make sure the platform (= the Smalltalk dialect we are running on) implements the protocol we need for system classes like Collection. An example would be to make sure Collection implements #count: with the semantics we need.!!GRPlatformTest methodsFor: 'tests-streams-seaside' stamp: 'jf 9/30/2009 01:06'!testReadStreamSeasideUpToAll	| stream string1 string2 |	stream := 'abc12def' readStream.	string1 := stream greaseUpToAll: '12'.	string2 := stream greaseUpToAll: '12'.	self assert: string1 = 'abc'.	self assert: string2 = 'def'.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 1/23/2010 13:29'!testCharacterTo	| actual expected |	actual := Array withAll: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-'.	actual := actual collect: [ :each | each greaseInteger ].	expected := #(		97		98		99		100		101		102		103		104		105		106		107		108		109		110		111		112		113		114		115		116		117		118		119		120		121		122		65		66		67		68		69		70		71		72		73		74		75		76		77		78		79		80		81		82		83		84		85		86		87		88		89		90		48		49		50		51		52		53		54		55		56		57		95		45	).	self assert: actual size = expected size.	actual 		with: expected		do: [ :first :second | self assert: first = second ]! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 1/10/2009 23:41'!testBlockContextWithPossibleArguments	| block |	block := [ :x | 1 + x ].	self assert: (block valueWithPossibleArguments: (Array with: 2)) = 3.	block := [ false not ].	self assert: (block valueWithPossibleArguments: (Array with: 3))! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 10/2/2007 06:54'!testEmptyOrNil	self assert: '' isEmptyOrNil.	self assert: nil isEmptyOrNil.	self assert: Array new isEmptyOrNil.	self deny: 'Timberwolf' isEmptyOrNil! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 2/9/2010 00:58'!testLabel	self assert: (self platform label isKindOf: String).	self deny: self platform label isEmpty! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 8/27/2011 15:10'!testBase64Decode	| input |	input := #(		'YW55IGNhcm5hbCBwbGVhc3VyZS4='  'any carnal pleasure.'		'YW55IGNhcm5hbCBwbGVhc3VyZQ==' 'any carnal pleasure'		'YW55IGNhcm5hbCBwbGVhc3Vy' 'any carnal pleasur'		'YW55IGNhcm5hbCBwbGVhc3U=' 'any carnal pleasu'		'YW55IGNhcm5hbCBwbGVhcw==' 'any carnal pleas').	1 to: input size by: 2 do: [ :index |		| decoded expected |		decoded := GRPlatform current base64Decode: (input at: index).		expected := input at: index + 1.		self assert: decoded = expected ]! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 1/10/2009 22:23'!testNumArgs	self assert: #not numArgs isZero.	self assert: #+ numArgs = 1.	self assert: #and: numArgs = 1.	self assert: #value:value: numArgs = 2! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 2/9/2010 00:43'!testVersion	self assert: (self platform version isKindOf: GRVersion).	self assert: (self platform versionString isKindOf: String).	self deny: self platform versionString isEmpty! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 11/10/2007 17:19'!testIfNil	self assert: (nil ifNil: [ 1 ]) = 1.	self assert: (1 ifNil: [ 2 ]) = 1! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 10/28/2007 14:42'!testAsNumber	self assert: 2007 asNumber = 2007.	self assert: '2007' asNumber = 2007! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 3/6/2012 19:34'!testSeconds	self assert: Time now seconds isInteger! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 4/15/2010 19:20'!testNewline	self assert: GRPlatform current newline isString.	self deny: GRPlatform current newline isEmpty! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 10/28/2007 14:42'!testFixCallbackTemps	"Make sure that #fixCallbackTemps is properly understood by block-contexts. Make sure that this is either a nop for Smalltalks with true block closures, or it properly fixes the context otherwise."	| array blocks values |	array := #(1 2 3).	blocks := array collect: [ :each | [ each ] fixCallbackTemps ].	values := blocks collect: [ :each | each value ].	self assert: values = array! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 2/5/2011 10:12'!testPathSeparator	self assert: GRPlatform current pathSeparator isString! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 12/3/2009 10:54'!testIfTrueIfFalse	self assert: (false ifFalse: [ #false ]) = #false.	self assert: (false ifTrue: [ #true ]) isNil.	self assert: (true ifTrue: [ #true ]) = #true.	self assert: (true ifFalse: [ #false ]) isNil.	self assert: (true ifTrue: [ #true ] ifFalse: [ #false ]) = #true.	self assert: (false ifTrue: [ #true ] ifFalse: [ #false ]) = #false.	self assert: (true ifFalse: [ #false ] ifTrue: [ #true ]) = #true.	self assert: (false ifFalse: [ #false ] ifTrue: [ #true ]) = #false! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 12/18/2009 10:30'!testDaysInMonthForYear	(1 to: 12) with: #(31 28 31 30 31 30 31 31 30 31 30 31) do: [ :month :days |		self assert: days = (Date daysInMonth: (Date nameOfMonth: month) forYear: 2007) ]! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 2/25/2007 23:08'!testSymbolAsMutator	"test for:	Symbol >> #asMutator	^ (self copyWith: $:) asSymbol"	self assert: #name asMutator = #name:! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 1/22/2012 16:23'!testGreaseIntegerOnCharacterAscii	"ASCII (1 byte)"	self assert: $a greaseInteger = 97.	self assert: $A greaseInteger = 65! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 9/30/2009 01:08'!testGreaseIntegerOnString	self assert: '' greaseInteger isNil.	self assert: 'a' greaseInteger isNil.	self assert: ' 1' greaseInteger isNil.	self assert: 'a1' greaseInteger isNil.	self assert: '-' greaseInteger isNil.	self assert: '-a' greaseInteger isNil.	self assert: '0' greaseInteger = 0.	self assert: '12' greaseInteger = 12.	self assert: '123' greaseInteger = 123.	self assert: '123456789' greaseInteger = 123456789.	self assert: '-0' greaseInteger = 0.	self assert: '-12' greaseInteger = -12.	self assert: '-123.4' greaseInteger = -123.	self assert: '-123456789' greaseInteger = -123456789! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 2/15/2010 23:06'!testIsCollection	self deny: Object new isCollection! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 4/15/2010 19:27'!testConvertToSmalltalkNewlines	| expected |	expected := 'a' , GRPlatform current newline , 'b'.	self assert: (GRPlatform current convertToSmalltalkNewlines: nil) isNil.	self assert: (GRPlatform current convertToSmalltalkNewlines: '') = ''.	self assert: (GRPlatform current convertToSmalltalkNewlines: 'abc') = 'abc'.	self 		assert: (GRPlatform current convertToSmalltalkNewlines: 'a' , (String with: Character cr with: Character lf) , 'b')			= expected		description: 'Multics, Unix and Unix-like systems (GNU/Linux, AIX, Xenix, Mac OS X, FreeBSD, etc.), BeOS, Amiga, RISC OS, and others'.	self		assert: (GRPlatform current convertToSmalltalkNewlines: 'a' , (String with: Character lf) , 'b')			= expected		description: 'DEC RT-11 and most other early non-Unix, non-IBM OSes, CP/M, MP/M, MS-DOS, OS/2, Microsoft Windows, Symbian OS'.	self 		assert: (GRPlatform current convertToSmalltalkNewlines: 'a' , (String with: Character cr) , 'b')			= expected		description: 'Commodore 8-bit machines, TRS-80, Apple II family, Mac OS up to version 9 and OS-9'! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 6/5/2009 08:59'!testTotalSeconds	"Answer the total seconds since the Squeak epoch: 1 January 1901."	| seconds |	seconds := Time totalSeconds.	self assert: seconds isInteger.	self assert: seconds > 3421645167! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 12/18/2009 12:26'!testBlockValuableProtocol	self assert: [ nil ] argumentCount isZero.	self assert: [ :x | x ] argumentCount = 1.	self assert: [ :a :b | a + b ] argumentCount = 2.	self 		shouldnt: [ [ nil ] fixCallbackTemps ]		raise: Error.	self 		shouldnt: [ [ :x | x ] fixCallbackTemps ]		raise: Error.	self 		shouldnt: [ [ :a :b | a + b ] fixCallbackTemps ]		raise: Error! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 12/26/2010 21:14'!testGreaseIntegerOnCharacterLatin1	"Latin-1 (2 byte)"	| oWithStroke |	oWithStroke := self decodeUtf8Character: #(195 152 ).	self assert: oWithStroke greaseInteger = 216! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 12/26/2010 21:16'!testGreaseIntegerOnCharacterSmp	"SMP (4 byte)"	| manna |	manna := self decodeUtf8Character: #(240 144 140 188 ).	self assert: manna greaseInteger = 66364! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 5/2/2009 17:18'!testIsCharacter	self deny: 7 isCharacter.	self assert: $7 isCharacter! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 10/28/2007 14:42'!testCharacterAsUnicode	"test for:	Character >> #asUnicode		^self asInteger"	self assert: $S asUnicode = 83! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 7/16/2015 15:58'!testGreaseString	self assert: 'Timberwolf' greaseString = 'Timberwolf'.	self assert: #DireWolf greaseString = 'DireWolf'.	self assert: true greaseString = 'true'.	self assert: 666 greaseString = '666'.	"make sure we're not immediate"	self assert: ((2 raisedTo: 64) + 1) greaseString = '18446744073709551617'.	"make sure we're not immediate"	self assert: ((2 raisedTo: 64) + 1) negated greaseString = '-18446744073709551617'.	self assert: $A greaseString = 'A'.	self assert: nil greaseString = 'nil'.	[	"Smalltalk/X has constant folding so 1 / 0 will be evaluated at compile time		resulting in an error when loading the code."		1 perform: #/ with: 0 ] 		on: ZeroDivide		do: [ :error | self assert: error greaseString isString ].	self assert: 15.25 greaseString = '15.25'.	self assert: nil greaseString isString.	self assert: (4 @ 2) greaseString = '4@2'.	"#greaseString for a byte array should not do any decoding	this is in place to catch encoding errors early"	self assert: #(101 97 ) asByteArray greaseString ~= 'ea'.	self assert: #(101 97 ) asByteArray greaseString isString.	self assert: Object new greaseString isString.	"Printing scaled decimals (https://github.com/SeasideSt/Grease/issues/1)"	self assert: 1.21s3 greaseString = '1.210'.	self assert: -1.21s3 greaseString = '-1.210'	! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 9/13/2008 14:36'!testDateArithmetic	| today tomorrow oneDay minusOneDay |	today := DateAndTime year: 2008 month: 9 day: 13 hour: 14 minute: 32 second: 05 offset: Duration zero.	tomorrow := DateAndTime year: 2008 month: 9 day: 14 hour: 14 minute: 32 second: 05 offset: Duration zero.	oneDay := Duration days: 1 hours: 0 minutes: 0 seconds: 0.	minusOneDay := Duration days: -1 hours: 0 minutes: 0 seconds: 0.	self assert: tomorrow - today = oneDay.	self assert: today - tomorrow = minusOneDay.	self assert: today + oneDay = tomorrow.	self assert: tomorrow - oneDay = today.	self assert: tomorrow + minusOneDay = today.	self assert: today - minusOneDay = tomorrow! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 3/16/2009 19:18'!testSecureHashFor	"Make sure the platform class provides a #secureHashFor: method. The method is called by Seaside when hashing passwords. The Squeak implementation returns a SHA-1 hash but another equivalent hash method could also be used."		| a b |	a := self platform secureHashFor: 'foobar'.	b := self platform secureHashFor: 'foobar'.		self assert: (a = b)! !!GRPlatformTest methodsFor: 'tests' stamp: 'jf 9/30/2009 01:07'!testGreaseIntegerOnNumber	self assert: 2007 greaseInteger = 2007.	self assert: 2007.0 greaseInteger = 2007.	self assert: 2007.1 greaseInteger = 2007.	self assert: 2007.9 greaseInteger = 2007! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:32'!testIsKeyword	self deny: #isKeyword isKeyword.	self deny: #+ isKeyword.	self assert: #isKeyword: isKeyword.	self assert: #isKeyword:isKeyword: isKeyword! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 8/23/2014 11:43'!testBindingOf	| binding |	binding := GRPlatform current bindingOf: GRPlatform.	self assert: binding value == GRPlatform! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:32'!testIsUnary	self assert: #isUnary isUnary.	self deny: #+ isUnary.	self deny: #isUnary: isUnary.	self deny: #isUnary:isUnary: isUnary! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 9/29/2009 22:54'!testStackDepth	| stackDepth someBlock |	stackDepth := self platform stackDepth.	self assert: stackDepth isInteger.	self assert: stackDepth > 0.	someBlock := [ self assert: self platform stackDepth > stackDepth ].	someBlock value.	self assert: stackDepth = self platform stackDepth! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 7/25/2011 18:36'!testPrintStringLimitedTo	| longString shortString |	longString := String streamContents: [ :stream |		1 to: 1000 do: [ :i | stream nextPutAll: i printString ] ].	"Squeak implementation adds 9 characters to limited string and VA Smalltalk adds 10, so we can't do an exact count."	self assert: longString printString size > 65.	shortString := longString printStringLimitedTo: 50.	self assert: shortString size < 65! !!GRPlatformTest methodsFor: 'tests' stamp: 'pmm 12/26/2010 21:15'!testGreaseIntegerOnCharacterBmp	"BMP (3 byte)"	| euro |	euro := self decodeUtf8Character: #(226 130 172 ).	self assert: euro greaseInteger = 8364! !!GRPlatformTest methodsFor: 'tests' stamp: 'lr 1/23/2010 13:28'!testDigitValue	'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' 		with: (0 to: 35)		do: [ :each :expected | self assert: each digitValue = expected ]! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jgf 1/23/2009 15:28'!testWriteStreamNextPutAll	"ANSI 5.9.4.4"		| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'abc'.	self assert: stream contents = 'abc'.		stream := WriteStream on: String new.	stream nextPutAll: #($a $b $c).	self assert: stream contents = 'abc'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/23/2009 11:41'!testReadStreamReset	"ANSI 5.9.1.6"		| stream |	stream := 'abc' readStream.	stream next: 2.	stream reset.	self assert: stream next = $a! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/22/2009 22:06'!testReadStreamContents	"ANSI 5.9.3.1"		| stream |	stream := 'abc' readStream.	self assert: stream contents = 'abc'.	stream next: 2.	self assert: stream contents = 'abc'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/22/2009 22:02'!testReadStreamSkip	"ANSI 5.9.2.9"		| stream |	stream := 'abcd' readStream.	self assert: (stream skip: 2; peek) = $c! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'mlucas-smith 6/3/2009 22:33'!testWriteStreamCrLf	| stream |	stream := WriteStream on: String new.	stream crlf.	self assert: stream contents first codePoint = 13.	self assert: stream contents second codePoint = 10! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamAtEnd	"ANSI 5.9.2.1"	| stream |	stream := GRPlatform current readWriteCharacterStream.	self assert: stream atEnd.	stream		nextPut: $a;		reset.	self deny: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamUpToEnd	"Not defined by ANSI."	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: stream upToEnd = 'abcd'.	self assert: stream atEnd.	self assert: stream upToEnd = ''.	self assert: stream atEnd.	stream reset.	stream upTo: $b.	self assert: stream upToEnd = 'cd'.	self assert: stream atEnd.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: stream upToEnd = #(97 98 99 100 ) asByteArray.	self assert: stream atEnd.	self assert: stream upToEnd = #() asByteArray.	self assert: stream atEnd.	stream reset.	stream upTo: 98.	self assert: stream upToEnd = #(99 100 ) asByteArray.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamContents	"ANSI 5.9.3.1"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abc';		reset.	self assert: stream contents = 'abc'.	stream next: 2.	self assert: stream contents = 'abc'.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abc' asByteArray;		reset.	self assert: stream contents = 'abc' asByteArray.	stream next: 2.	self assert: stream contents = 'abc' asByteArray! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamPeek	"ANSI 5.9.2.7"	| stream |	stream := GRPlatform current readWriteCharacterStream.	self assert: stream peek isNil.	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: stream peek = $a.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: stream peek = 97! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'pmm 9/1/2012 15:32'!testRandomGenerator	| generator collection |	generator := self platform newRandom.	self should: [ generator nextInt: 0 ] raise: Error.	self assert: (generator nextInt: 1) = 1.	collection := (1 to: 200) collect: [ :ea | generator nextInt: 2 ].	self assert: (collection includes: 1).	self assert: (collection includes: 2).	self assert: collection asSet size = 2.	collection := 1 to: 5.	self assert: (collection includes: (generator randomFrom: collection)).	collection := -1.5 to: 3.5.	self assert: (collection includes: (generator randomFrom: collection)).	collection := #(1 2 3 4 5).	self assert: (collection includes: (generator randomFrom: collection)).	collection := #(1 2 3 4 5) asSet.	self assert: (collection includes: (generator randomFrom: collection))! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'JohanBrichau 9/14/2013 11:49'!testWriteStreamContents	| stream |	stream := GRPlatform current writeCharacterStreamOn: String new.	self assert: stream contents = ''.	stream		nextPutAll: 'abcdef'.	self assert: stream contents = 'abcdef'.	stream		reset;		nextPutAll: 'gh'.	self assert: stream contents = 'gh'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamReset	"ANSI 5.9.1.6"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abc';		reset.	stream next: 2.	stream reset.	self assert: stream next = $a.	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abc';		reset.	stream nextPutAll: 'def'.	self assert: stream contents = 'def'.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abc' asByteArray;		reset.	stream next: 2.	stream reset.	self assert: stream next = 97! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamUpTo	"ANSI 5.9.2.11"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: (stream upTo: $c) = 'ab'.	self assert: stream next = $d.	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: (stream upTo: $x) = 'abcd'.	self assert: stream atEnd.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: (stream upTo: 99) = #(97 98 ) asByteArray.	self assert: stream next = 100.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: (stream upTo: 120) = #(97 98 99 100 ) asByteArray.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jgf 1/23/2009 15:29'!testWriteStreamNextPut	"ANSI 5.9.4.3"		| stream |	stream := WriteStream on: String new.	stream nextPut: $a.	self assert: stream contents = 'a'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamNext	"ANSI 5.9.2.3"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: stream next = $a.	self assert: (stream next: 0) = ''.	self assert: (stream next: 1) = 'b'.	self assert: (stream next: 2) = 'cd'.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: stream next = 97.	self assert: (stream next: 0) = '' asByteArray.	self assert: (stream next: 1) = 'b' asByteArray.	self assert: (stream next: 2) = 'cd' asByteArray! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'JohanBrichau 9/14/2013 11:53'!testWriteStreamPosition	| stream |	stream := GRPlatform current writeCharacterStreamOn: String new.	self assert: stream position = 0.	stream nextPutAll: 'abc'.	self assert: stream position = 3.	stream reset.	self assert: stream position = 0! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamNegativeSkip	"ANSI does not mention negative values being used with #skip: but we	believe they work consistently. If not, we need to update our coding	conventions to make sure we never do this."	| stream position |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	stream		next;		next.	position := stream position.	self assert: stream peek = $c.	stream skip: -1.	self assert: stream position = (position - 1).	self assert: stream peek = $b.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	stream		next;		next.	position := stream position.	self assert: stream peek = 99.	stream skip: -1.	self assert: stream position = (position - 1).	self assert: stream peek = 98! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 7/31/2009 13:33'!testReadStreamUpToEnd	"Not defined by ANSI."		| stream |	stream := 'abcd' readStream.	self assert: stream upToEnd = 'abcd'.	self assert: stream atEnd.	self assert: stream upToEnd = ''.	self assert: stream atEnd.		stream := 'abcd' readStream.	stream upTo: $b.	self assert: stream upToEnd = 'cd'.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'mlucas-smith 6/3/2009 22:33'!testReadStreamUpTo	"ANSI 5.9.2.11"		| stream |	stream := 'abcd' readStream.	self assert: (stream upTo: $c) = 'ab'.	self assert: stream next = $d.		stream := 'abcd' readStream.	self assert: (stream upTo: $x) = 'abcd'.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamTab	"ANSI 5.9.4.6"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream tab.	self assert: stream contents first = Character tab! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'pmm 9/14/2013 16:37'!testReadWriteStreamNextPutAll	"ANSI 5.9.4.4"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream nextPutAll: 'abc'.	self assert: stream contents = 'abc'.	stream := GRPlatform current readWriteCharacterStream.	stream nextPutAll: #($a $b $c).	self assert: stream contents = 'abc'.	stream := GRPlatform current readWriteByteStream.	stream nextPutAll: #(97 98 99 ) asByteArray.	self assert: stream contents = 'abc' asByteArray! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jgf 1/23/2009 15:28'!testWriteStreamTab	"ANSI 5.9.4.6"		| stream |	stream := WriteStream on: String new.	stream tab.	self assert: stream contents first = Character tab! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/22/2009 22:00'!testReadStreamNext	"ANSI 5.9.2.3"		| stream |	stream := 'abcd' readStream.	self assert: stream next = $a.	self assert: (stream next: 0) = ''.	self assert: (stream next: 1) = 'b'.	self assert: (stream next: 2) = 'cd'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/22/2009 22:00'!testReadStreamPeek	"ANSI 5.9.2.7"		| stream |	stream := 'abcd' readStream.	self assert: stream peek = $a.		stream := '' readStream.	self assert: stream peek isNil! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamSkip	"ANSI 5.9.2.9"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abcd';		reset.	self assert: (stream			skip: 2;			peek) = $c.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abcd' asByteArray;		reset.	self assert: (stream			skip: 2;			peek) = 99! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jgf 1/23/2009 15:28'!testWriteStreamReset	"ANSI 5.9.1.6"		| stream |	stream := WriteStream on: String new.	stream nextPutAll: 'abc'.	stream reset.	stream nextPutAll: 'def'.	self assert: stream contents = 'def'! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/14/2009 13:52'!testReadStreamNegativeSkip	"ANSI does not mention negative values being used with #skip: but we	believe they work consistently. If not, we need to update our coding	conventions to make sure we never do this."		| stream position |	stream := 'abcd' readStream.	stream next; next.	position := stream position.	self assert: (stream peek) = $c.	stream skip: -1.	self assert: stream position = (position - 1).	self assert: (stream peek) = $b! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamNextPut	"ANSI 5.9.4.3"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream nextPut: $a.	self assert: stream contents = 'a'.	stream := GRPlatform current readWriteByteStream.	stream nextPut: 97.	self assert: stream contents = 'a' asByteArray! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 7/31/2009 13:40'!testReadStreamPosition	"ANSI 5.9.1.4 and 5.9.1.5"		| stream |	stream := 'abc' readStream.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.		stream position: 1.	self assert: stream position = 1.	self assert: stream next = $b.	stream position: 0.	self assert: stream position = 0.	self assert: stream next = $a.	stream position: 3.	self assert: stream atEnd	! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'lr 1/22/2009 22:01'!testReadStreamAtEnd	"ANSI 5.9.2.1"		| stream |	stream := '' readStream.	self assert: stream atEnd.	stream := 'a' readStream.	self deny: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jf 9/30/2009 00:19'!testReadWriteStreamPosition	"ANSI 5.9.1.4 and 5.9.1.5"	| stream |	stream := GRPlatform current readWriteCharacterStream.	stream		nextPutAll: 'abc';		reset.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream position: 1.	self assert: stream position = 1.	self assert: stream next = $b.	stream position: 0.	self assert: stream position = 0.	self assert: stream next = $a.	stream position: 3.	self assert: stream atEnd.	stream := GRPlatform current readWriteByteStream.	stream		nextPutAll: 'abc' asByteArray;		reset.	self assert: stream position = 0.	stream next.	self assert: stream position = 1.	stream next.	self assert: stream position = 2.	stream next.	self assert: stream position = 3.	stream position: 1.	self assert: stream position = 1.	self assert: stream next = 98.	stream position: 0.	self assert: stream position = 0.	self assert: stream next = 97.	stream position: 3.	self assert: stream atEnd! !!GRPlatformTest methodsFor: 'tests-streams' stamp: 'jgf 1/23/2009 15:28'!testWriteStreamSpace	"ANSI 5.9.4.5"		| stream |	stream := WriteStream on: String new.	stream space.	self assert: stream contents first = Character space! !!GRPlatformTest methodsFor: 'tests-image' stamp: 'lr 3/16/2009 19:16'!testStartUpList	"A smoke test: checks if the test-class can be added and removed to the startup list."		[  self platform addToStartUpList: self class ]		ensure: [  self platform removeFromStartUpList: self class ]! !!GRPlatformTest methodsFor: 'tests-image' stamp: 'lr 3/16/2009 19:16'!testShutDownList	"A smoke test: checks if the test-class can be added and removed to the shutdown list."		[ self platform addToShutDownList: self class ]		ensure: [  self platform removeFromShutDownList: self class ]! !!GRPlatformTest methodsFor: 'private' stamp: 'pmm 9/2/2012 11:17'!decodeUtf8Character: aCollectionOfIntegers 	"Decodes a collection of bytes into a single character. We have this so we can avoid having non-ASCII characters in the source."	| codec toDecode decoded |	codec := GRCodec forEncoding: 'utf-8'.	toDecode := aCollectionOfIntegers asByteArray.	decoded := codec decode: toDecode.	self assert: decoded size = 1.	^ decoded first! !!GRPlatformTest methodsFor: 'accessing' stamp: 'jf 9/30/2009 00:19'!platform	^ GRPlatform current! !!GRPlatformTest methodsFor: 'tests-processes' stamp: 'mlucas-smith 6/3/2009 22:33'!testTerminate	| ensureRun ifCurtailedRun semaphore1 semaphore2 semaphore3 semaphore4 process |	ensureRun := false.	ifCurtailedRun := false.	semaphore1 := self platform semaphoreClass new.	semaphore2 := self platform semaphoreClass new.	semaphore3 := self platform semaphoreClass new.	semaphore4 := self platform semaphoreClass new.	process := [		[ [ semaphore1 signal. semaphore2 wait ]			ensure: [ ensureRun := true. semaphore3 signal ] ]			ifCurtailed: [ ifCurtailedRun := true. semaphore4 signal ] ] newProcess.	self deny: (self platform isProcessTerminated: process).	process resume.	semaphore1 wait.	self deny: (self platform isProcessTerminated: process).	self platform terminateProcess: process.	semaphore3 wait.	self assert: ensureRun.	semaphore4 wait.	self assert: ifCurtailedRun.	self assert: (self platform isProcessTerminated: process)! !TestCase subclass: #GRPrinterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'jf 9/30/2009 00:32'!testIsoDate	| printer |	printer := GRPrinter isoDate.	self assert: (printer print: (Date 				year: 1980				month: 6				day: 11)) = '1980-06-11'.	self assert: (printer print: (Date 				year: 2003				month: 12				day: 1)) = '2003-12-01'.	self assert: (printer print: (Date 				year: 800				month: 12				day: 24)) = '0800-12-24'! !!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'lr 2/6/2010 11:12'!testCookieTimestamp	| printer date |	printer := GRPrinter cookieTimestamp.	date := DateAndTime 		year: 2008		month: 8		day: 1		hour: 9		minute: 4		second: 4		offset: (Duration 				days: 0				hours: 0				minutes: 0				seconds: 0).	self assert: (printer print: date) = 'Fri, 01-Aug-2008 09:04:04 GMT'! !!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'jf 9/30/2009 00:32'!testRfc822	| printer date |	printer := GRPrinter rfc822.	date := DateAndTime 		year: 2008		month: 8		day: 1		hour: 9		minute: 4		second: 4		offset: (Duration 				days: 0				hours: -2				minutes: 0				seconds: 0).	self assert: (printer print: date) = 'Fri, 01 Aug 2008 09:04:04 -0200'.	date := DateAndTime 		year: 2008		month: 8		day: 31		hour: 19		minute: 41		second: 46		offset: (Duration 				days: 0				hours: 0				minutes: 30				seconds: 0).	self assert: (printer print: date) = 'Sun, 31 Aug 2008 19:41:46 +0030'! !!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'lr 2/6/2010 11:12'!testRfc822WithTimeZone	| printer date |	printer := GRPrinter rfc822WithTimeZone: 'GMT'.	date := DateAndTime 		year: 2008		month: 8		day: 1		hour: 9		minute: 4		second: 4		offset: (Duration 				days: 0				hours: 0				minutes: 0				seconds: 0).	self assert: (printer print: date) = 'Fri, 01 Aug 2008 09:04:04 GMT'! !!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'jf 9/30/2009 00:32'!testIsoTime	| printer |	printer := GRPrinter isoTime.	self assert: (printer print: (Time 				hour: 0				minute: 0				second: 0)) = '00:00:00'.	self assert: (printer print: (Time 				hour: 1				minute: 2				second: 3)) = '01:02:03'.	self assert: (printer print: (Time 				hour: 12				minute: 23				second: 34)) = '12:23:34'! !!GRPrinterTest methodsFor: 'tests-timestamp' stamp: 'jf 9/30/2009 00:32'!testHttp	| printer date offsetHour |	offsetHour := 2.	printer := GRPrinter httpDate.	date := DateAndTime 		year: 1994		month: 11		day: 6		hour: 8 + offsetHour		minute: 49		second: 37		offset: (Duration 				days: 0				hours: offsetHour				minutes: 0				seconds: 0).	self assert: (printer print: date) = 'Sun, 06 Nov 1994 08:49:37 GMT'! !!GRPrinterTest methodsFor: 'tests-currency' stamp: 'jf 9/30/2009 00:32'!testSwissCurrency	| printer |	printer := GRPrinter swissCurrency.	self assert: (printer print: 12.34) = 'CHF 12.35'.	self assert: (printer print: -12.39) = 'CHF -12.40'! !!GRPrinterTest methodsFor: 'tests-currency' stamp: 'jf 9/30/2009 00:32'!testUsCurrency	| printer |	printer := GRPrinter usCurrency.	self assert: (printer print: 12.34) = '$12.34'.	self assert: (printer print: -12.34) = '-$12.34'! !!GRPrinterTest methodsFor: 'tests-parts-time' stamp: 'lr 2/6/2010 11:06'!testUnpaddedSecond	| printer |	printer := GRPrinter unpaddedSecond.	self assert: (printer print: (Time hour: 0 minute: 0 second: 0)) = '0'.	self assert: (printer print: (Time hour: 0 minute: 0 second: 9)) = '9'.	self assert: (printer print: (Time hour: 0 minute: 0 second: 12)) = '12'! !!GRPrinterTest methodsFor: 'tests-parts-time' stamp: 'lr 2/6/2010 11:07'!testPaddedHour12	| printer |	printer := GRPrinter paddedHour12.	self assert: (printer print: (Time hour: 5 minute: 0 second: 0)) = '05'.	self assert: (printer print: (Time hour: 10 minute: 0 second: 0)) = '10'.	self assert: (printer print: (Time hour: 14 minute: 0 second: 0)) = '02'.	self assert: (printer print: (Time hour: 23 minute: 0 second: 0)) = '11'! !!GRPrinterTest methodsFor: 'tests-parts-time' stamp: 'lr 2/6/2010 11:07'!testUnpaddedHour24	| printer |	printer := GRPrinter unpaddedHour24.	self assert: (printer print: (Time hour: 5 minute: 0 second: 0)) = '5'.	self assert: (printer print: (Time hour: 10 minute: 0 second: 0)) = '10'.	self assert: (printer print: (Time hour: 14 minute: 0 second: 0)) = '14'.	self assert: (printer print: (Time hour: 23 minute: 0 second: 0)) = '23'! !!GRPrinterTest methodsFor: 'tests-parts-time' stamp: 'lr 2/6/2010 11:02'!testUnpaddedMinute	| printer |	printer := GRPrinter unpaddedMinute.	self assert: (printer print: (Time hour: 0 minute: 5 second: 0)) = '5'.	self assert: (printer print: (Time hour: 0 minute: 12 second: 0)) = '12'! !!GRPrinterTest methodsFor: 'tests-parts-time' stamp: 'lr 2/6/2010 11:05'!testUnpaddedHour12	| printer |	printer := GRPrinter unpaddedHour12.	self assert: (printer print: (Time hour: 5 minute: 0 second: 0)) = '5'.	self assert: (printer print: (Time hour: 10 minute: 0 second: 0)) = '10'.	self assert: (printer print: (Time hour: 14 minute: 0 second: 0)) = '2'.	self assert: (printer print: (Time hour: 23 minute: 0 second: 0)) = '11'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFloatPrinterNaN	| converter |	converter := GRNumberPrinter new.	self assert: (converter print: Float nan) = 'NaN'.	converter nan: 'Not A Number'.	self assert: (converter print: Float nan) = 'Not A Number'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testIntegerPrinter	| converter |	converter := GRNumberPrinter new.	self assert: (converter print: 1234) = '1234'.	self assert: (converter print: -1234) = '1234'.	converter separator: $..	self assert: (converter print: 1234) = '1.234'.	self assert: (converter print: 1234567) = '1.234.567'.	converter		base: 16;		separator: nil.	self assert: (converter print: 1234) = '4d2'.	self assert: (converter print: 123123) = '1e0f3'.	converter uppercase.	self assert: (converter print: 1234) = '4D2'.	self assert: (converter print: 123123) = '1E0F3'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testSignPrinter	| converter |	converter := GRSignPrinter new.	converter		negativePrinter: $-;		positivePrinter: $+.	self assert: (converter print: 12) = '+'.	self assert: (converter print: -12) = '-'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFileSizePrinterDecimal	| converter |	converter := GRPrinter decimalFileSize.	self assert: (converter print: 1) = '1 byte'.	self assert: (converter print: 2) = '2 bytes'.	self assert: (converter print: 30) = '30 bytes'.	self assert: (converter print: 500) = '500 bytes'.	self assert: (converter print: 6000) = '6.0 kB'.	self assert: (converter print: 70000) = '70.0 kB'.	self assert: (converter print: 800000) = '800.0 kB'.	self assert: (converter print: 9000000) = '9.0 MB'.	self assert: (converter print: 10000000) = '10.0 MB'.	self assert: (converter print: 200000000) = '200.0 MB'.	self assert: (converter print: 3000000000) = '3.0 GB'.	self assert: (converter print: 40000000000) = '40.0 GB'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testStringPrinterLength	| converter |	converter := GRStringPrinter new.	self assert: (converter print: 'foo') = 'foo'.	converter length: 3.	self assert: (converter print: 'foo') = 'foo'.	converter length: 1.	self assert: (converter print: 'foo') = 'f'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testComposedPrinter	| converter |	converter := GRSequentialPrinter new , 'CHF ' , GRNumberPrinter new.	self assert: (converter print: 1234) = 'CHF 1234'.	self assert: (converter print: -1234) = 'CHF 1234'.	converter := GRSignPrinter new , GRNumberPrinter new , '%'.	self assert: (converter print: 1234) = '1234%'.	self assert: (converter print: -1234) = '-1234%'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFloatPrinterPadding	| converter |	converter := GRNumberPrinter new.	converter digits: 3.	self assert: (converter print: 1) = '  1'.	self assert: (converter print: 12) = ' 12'.	self assert: (converter print: 123) = '123'.	self assert: (converter print: 1234) = '1234'.	converter padding: $*.	self assert: (converter print: 1) = '**1'.	self assert: (converter print: 12) = '*12'.	self assert: (converter print: 123) = '123'.	self assert: (converter print: 1234) = '1234'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFileSizePrinterBinary	| converter |	converter := GRPrinter binaryFileSize.	self assert: (converter print: 1) = '1 byte'.	self assert: (converter print: 2) = '2 bytes'.	self assert: (converter print: 30) = '30 bytes'.	self assert: (converter print: 500) = '500 bytes'.	self assert: (converter print: 6000) = '5.9 KiB'.	self assert: (converter print: 70000) = '68.4 KiB'.	self assert: (converter print: 800000) = '781.3 KiB'.	self assert: (converter print: 9000000) = '8.6 MiB'.	self assert: (converter print: 10000000) = '9.5 MiB'.	self assert: (converter print: 200000000) = '190.7 MiB'.	self assert: (converter print: 3000000000) = '2.8 GiB'.	self assert: (converter print: 40000000000) = '37.3 GiB'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFloatPrinterSeparator	| converter |	converter := GRNumberPrinter new.	converter		precision: 2;		separator: $*.	self assert: (converter print: 12345.0) = '12*345.00'.	self assert: (converter print: 0.6789) = '0.68'.	converter		precision: 4;		separator: $!!.	self assert: (converter print: 12345.0) = '12!!345.000!!0'.	self assert: (converter print: 0.6789) = '0.678!!9'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFloatPrinterInfinity	| converter |	converter := GRNumberPrinter new.	self assert: (converter print: Float infinity) = 'Infinite'.	self assert: (converter print: Float infinity negated) = 'Infinite'.	converter infinite: 'very huge'.	self assert: (converter print: Float infinity) = 'very huge'.	self assert: (converter print: Float infinity negated) = 'very huge'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testFloatPrinter	| converter |	converter := GRNumberPrinter new precision: 2.	self assert: (converter print: 1.009) = '1.01'.	self assert: (converter print: 1.01) = '1.01'.	self assert: (converter print: 1.019) = '1.02'.	self assert: (converter print: 1.25) = '1.25'.	self assert: (converter print: 1.254) = '1.25'.	self assert: (converter print: 1.256) = '1.26'.	self assert: (converter print: 1.009) = '1.01'.	self assert: (converter print: 0.9) = '0.90'.	self assert: (converter print: 0.99) = '0.99'.	self assert: (converter print: 0.999) = '1.00'.	self assert: (converter print: 0.9999) = '1.00'.	self assert: (converter print: -0.9) = '0.90'.	self assert: (converter print: -0.99) = '0.99'.	self assert: (converter print: -0.999) = '1.00'.	self assert: (converter print: -0.9999) = '1.00'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testStringPrinter	| converter |	converter := GRStringPrinter new.	self assert: (converter print: 123) = '123'.	self assert: (converter print: 'foo') = 'foo'.	self assert: (converter print: true) = 'true'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testStringPrinterPad	| converter |	converter := GRStringPrinter new.	converter		character: $*;		length: 5.	converter padLeft.	self assert: (converter print: 'foo') = '**foo'.	converter padRight.	self assert: (converter print: 'foo') = 'foo**'.	converter padCenter.	self assert: (converter print: 'foo') = '*foo*'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:33'!testStringPrinterTrim	| converter |	converter := GRStringPrinter new.	self assert: (converter print: ' foo ') = ' foo '.	converter trimLeft.	self assert: (converter print: ' foo ') = 'foo '.	converter trimRight.	self assert: (converter print: ' foo ') = ' foo'.	converter trimBoth.	self assert: (converter print: ' foo ') = 'foo'! !!GRPrinterTest methodsFor: 'tests' stamp: 'jf 9/30/2009 00:32'!testOrdinalizePrinter	| converter |	converter := GRNumberPrinter new , GROrdinalizePrinter new.	self assert: (converter print: 1) = '1st'.	self assert: (converter print: 2) = '2nd'.	self assert: (converter print: 3) = '3rd'.	self assert: (converter print: 4) = '4th'.	self assert: (converter print: 10) = '10th'.	self assert: (converter print: 111) = '111th'.	self assert: (converter print: 212) = '212th'.	self assert: (converter print: 313) = '313th'.	self assert: (converter print: 414) = '414th'.	self assert: (converter print: 20) = '20th'.	self assert: (converter print: 121) = '121st'.	self assert: (converter print: 222) = '222nd'.	self assert: (converter print: 323) = '323rd'.	self assert: (converter print: 424) = '424th'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:09'!testFullMonthName	| printer |	printer := GRPrinter fullMonthName.	self assert: (printer print: (Date year: 2000 month: 8 day: 1)) = 'August'.	self assert: (printer print: (Date year: 2000 month: 11 day: 1)) = 'November'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:03'!testPaddedCentury	| printer |	printer := GRPrinter paddedCentury.	self assert: (printer print: (Date year: 1980 month: 1 day: 1)) = '80'.	self assert: (printer print: (Date year: 2009 month: 1 day: 1)) = '09'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:09'!testUnpaddedDay	| printer |	printer := GRPrinter unpaddedDay.	self assert: (printer print: (Date year: 2000 month: 1 day: 4)) = '4'.	self assert: (printer print: (Date year: 2000 month: 1 day: 19)) = '19'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:07'!testUnpaddedMonth	| printer |	printer := GRPrinter unpaddedMonth.	self assert: (printer print: (Date year: 2000 month: 8 day: 1)) = '8'.	self assert: (printer print: (Date year: 2000 month: 11 day: 1)) = '11'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:10'!testFullWeekName	| printer |	printer := GRPrinter fullWeekName.	self assert: (printer print: (Date year: 1980 month: 1 day: 1)) = 'Tuesday'.	self assert: (printer print: (Date year: 2000 month: 1 day: 1)) = 'Saturday'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:08'!testUnpaddedYear	| printer |	printer := GRPrinter unpaddedYear.	self assert: (printer print: (Date year: 766 month: 1 day: 1)) = '766'.	self assert: (printer print: (Date year: 1980 month: 1 day: 1)) = '1980'.	self assert: (printer print: (Date year: 2009 month: 1 day: 1)) = '2009'! !!GRPrinterTest methodsFor: 'tests-parts-date' stamp: 'lr 2/6/2010 11:10'!testUnpaddedCentury	| printer |	printer := GRPrinter unpaddedCentury.	self assert: (printer print: (Date year: 1980 month: 1 day: 1)) = '80'.	self assert: (printer print: (Date year: 2009 month: 1 day: 1)) = '9'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testPadLeft	| converter |	converter := GRPrinter new.	self assert: (converter 			pad: ''			left: $*			to: 3) = '***'.	self assert: (converter 			pad: '1'			left: $*			to: 3) = '**1'.	self assert: (converter 			pad: '12'			left: $*			to: 3) = '*12'.	self assert: (converter 			pad: '123'			left: $*			to: 3) = '123'.	self assert: (converter 			pad: '1234'			left: $*			to: 3) = '1234'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testPadRight	| converter |	converter := GRPrinter new.	self assert: (converter 			pad: ''			right: $*			to: 3) = '***'.	self assert: (converter 			pad: '1'			right: $*			to: 3) = '1**'.	self assert: (converter 			pad: '12'			right: $*			to: 3) = '12*'.	self assert: (converter 			pad: '123'			right: $*			to: 3) = '123'.	self assert: (converter 			pad: '1234'			right: $*			to: 3) = '1234'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testDigitsOfBase	| converter |	converter := GRNumberPrinter new.	self assert: (converter 			digitsOf: 1234			base: 2) = '10011010010'.	self assert: (converter 			digitsOf: 1234			base: 3) = '1200201'.	self assert: (converter 			digitsOf: 1234			base: 4) = '103102'.	self assert: (converter 			digitsOf: 1234			base: 5) = '14414'.	self assert: (converter 			digitsOf: 1234			base: 6) = '5414'.	self assert: (converter 			digitsOf: 1234			base: 7) = '3412'.	self assert: (converter 			digitsOf: 1234			base: 8) = '2322'.	self assert: (converter 			digitsOf: 1234			base: 9) = '1621'.	self assert: (converter 			digitsOf: 1234			base: 10) = '1234'.	self assert: (converter 			digitsOf: 1234			base: 11) = 'a22'.	self assert: (converter 			digitsOf: 1234			base: 12) = '86a'.	self assert: (converter 			digitsOf: 1234			base: 13) = '73c'.	self assert: (converter 			digitsOf: 1234			base: 14) = '642'.	self assert: (converter 			digitsOf: 1234			base: 15) = '574'.	self assert: (converter 			digitsOf: 1234			base: 16) = '4d2'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testPadCenter	| converter |	converter := GRPrinter new.	self assert: (converter 			pad: ''			center: $*			to: 3) = '***'.	self assert: (converter 			pad: '1'			center: $*			to: 3) = '*1*'.	self assert: (converter 			pad: '12'			center: $*			to: 3) = '12*'.	self assert: (converter 			pad: '123'			center: $*			to: 3) = '123'.	self assert: (converter 			pad: '1234'			center: $*			to: 3) = '1234'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testSeparateLeft	| converter |	converter := GRNumberPrinter new.	self assert: (converter 			separate: ''			left: $*) = ''.	self assert: (converter 			separate: '1'			left: $*) = '1'.	self assert: (converter 			separate: '12'			left: $*) = '12'.	self assert: (converter 			separate: '123'			left: $*) = '123'.	self assert: (converter 			separate: '1234'			left: $*) = '123*4'.	self assert: (converter 			separate: '12345'			left: $*) = '123*45'.	self assert: (converter 			separate: '123456'			left: $*) = '123*456'.	self assert: (converter 			separate: '1234567'			left: $*) = '123*456*7'.	self assert: (converter 			separate: '12345678'			left: $*) = '123*456*78'.	self assert: (converter 			separate: '123456789'			left: $*) = '123*456*789'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testSeparateRight	| converter |	converter := GRNumberPrinter new.	self assert: (converter 			separate: ''			right: $*) = ''.	self assert: (converter 			separate: '1'			right: $*) = '1'.	self assert: (converter 			separate: '12'			right: $*) = '12'.	self assert: (converter 			separate: '123'			right: $*) = '123'.	self assert: (converter 			separate: '1234'			right: $*) = '1*234'.	self assert: (converter 			separate: '12345'			right: $*) = '12*345'.	self assert: (converter 			separate: '123456'			right: $*) = '123*456'.	self assert: (converter 			separate: '1234567'			right: $*) = '1*234*567'.	self assert: (converter 			separate: '12345678'			right: $*) = '12*345*678'.	self assert: (converter 			separate: '123456789'			right: $*) = '123*456*789'! !!GRPrinterTest methodsFor: 'tests-utilites' stamp: 'jf 9/30/2009 00:32'!testDigitsOf	| converter |	converter := GRNumberPrinter new.	self assert: (converter 			digitsOf: 0.0			base: 10) = '0'.	self assert: (converter 			digitsOf: 1.0			base: 10) = '1'.	self assert: (converter 			digitsOf: -1.0			base: 10) = '1'.	self assert: (converter 			digitsOf: -1234567890			base: 10) = '1234567890'.	self assert: (converter 			digitsOf: 1234567890			base: 10) = '1234567890'.	self assert: (converter 			digitsOf: -9876543210			base: 10) = '9876543210'.	self assert: (converter 			digitsOf: 9876543210			base: 10) = '9876543210'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GRPrinterTest class	instanceVariableNames: ''!!GRPrinterTest class methodsFor: 'accessing' stamp: 'lr 2/6/2010 10:14'!packageNamesUnderTest	^ #('Grease-Core')! !GRCollectionTest subclass: #GRSetTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRSetTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 01:51'!collectionClass	^ Set! !!GRSetTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ false! !!GRSetTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:34'!isExtensible	^ true! !!GRSetTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	^ true! !TestCase subclass: #GRSmallDictionaryTest	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRSmallDictionaryTest methodsFor: 'tests' stamp: 'jf 2/15/2010 22:54'!testWithAll	| dict |	dict := (Dictionary new at: '1' put: 'foo'; yourself).	collection := self collectionClass withAll: dict.	self assertAssociations: (Array with: '1' -> 'foo').		dict := (GROrderedMultiMap new at: '1' put: 'foo'; at: '1' add: 'bar'; yourself).	collection := self collectionClass withAll: dict.	self assertAssociations:		(self allowsDuplicateKeys			ifFalse: [ Array with: '1' -> 'bar' ]			ifTrue: [ Array with: '1' -> 'foo' with: '1' -> 'bar' ])! !!GRSmallDictionaryTest methodsFor: 'tests' stamp: 'jf 2/15/2010 16:05'!testCopy	| other |	collection at: 1 put: 'foo'; at: 2 put: 'bar'.	other := collection copy.	collection at: 1 put: 'zork'; at: 3 put: 'zonk'.	other at: 2 put: 'other'.		self assert: collection size = 3.	self assert: (collection at: 1) = 'zork'.	self assert: (collection at: 2) = 'bar'.	self assert: (collection at: 3) = 'zonk'.		self assert: other size = 2.	self assert: (other at: 1) = 'foo'.	self assert: (other at: 2) = 'other'! !!GRSmallDictionaryTest methodsFor: 'tests' stamp: 'jf 2/15/2010 16:05'!testGrow	1 to: 100 do: [ :i |		collection at: i put: i negated.		self assert: collection size = i.		[ :array :factor |			self assert: array size = i.			1 to: i do: [ :j | self assert: (array at: j) = (factor * j) ] ]				value: collection keys value: 1;				value: collection values value: -1 ]! !!GRSmallDictionaryTest methodsFor: 'tests-enumerating' stamp: 'pmm 9/1/2012 15:33'!testKeysAndValuesDo	| iterated |	collection keysAndValuesDo: [ :key :value |		self assert: false ].	collection add: '1' -> 'foo'; add: '2' -> 'bar'; add: '1' -> 'baz'.	iterated := Array streamContents: [ :stream |		collection keysAndValuesDo: [ :key :value |			stream nextPut: key -> value ] ].	self assert: iterated size = (self allowsDuplicateKeys ifTrue: [ 3 ] ifFalse: [ 2 ]).	self assert: iterated first =		(self allowsDuplicateKeys ifTrue: [ '1' -> 'foo' ] ifFalse: [ '1' -> 'baz' ]).	self assert: iterated second = ('2' -> 'bar').	self allowsDuplicateKeys ifTrue: [		self assert: iterated third = ('1' -> 'baz') ]! !!GRSmallDictionaryTest methodsFor: 'tests-enumerating' stamp: 'jf 2/15/2010 16:05'!testValues	collection add: '1' -> 'foo'; add: '2' -> 'bar'; add: '1' -> 'baz'.	self assert: collection values =		(self allowsDuplicateKeys ifTrue: [ #('foo' 'bar' 'baz') ] ifFalse: [ #('baz' 'bar') ])! !!GRSmallDictionaryTest methodsFor: 'tests-enumerating' stamp: 'jf 2/15/2010 16:05'!testKeys	collection add: '1' -> 'foo'; add: '2' -> 'bar'; add: '1' -> 'baz'.	self assert: collection keys =		(self allowsDuplicateKeys ifTrue: [ #('1' '2' '1') ] ifFalse: [ #('1' '2') ])! !!GRSmallDictionaryTest methodsFor: 'tests-enumerating' stamp: 'jf 2/15/2010 16:05'!testDo	| result |	result := OrderedCollection new.	collection at: '1' put: 'foo'; at: '2' put: 'bar'.	collection do: [ :each | result add: each ].	self assert: result asArray = #( 'foo' 'bar' )! !!GRSmallDictionaryTest methodsFor: 'tests-enumerating' stamp: 'jf 2/15/2010 16:05'!testKeysDo	| result |	result := OrderedCollection new.	collection add: '1' -> 'foo'; add: '2' -> 'bar'; add: '1' -> 'baz'.	collection keysDo: [ :each | result add: each ].	self assert: result asArray = 		(self allowsDuplicateKeys ifTrue: [ #('1' '2' '1') ] ifFalse: [ #('1' '2') ])! !!GRSmallDictionaryTest methodsFor: 'asserting' stamp: 'jf 2/15/2010 16:05'!assertAssociations: anOrderedCollection	| associations iterated |	associations := collection associations.	iterated := Array streamContents: [ :stream |		collection associationsDo: [ :each | stream nextPut: each ] ].	self assert: associations size = anOrderedCollection size.	self assert: iterated size = anOrderedCollection size.	1 to: anOrderedCollection size do: [ :index |		self assert: (associations at: index) = (anOrderedCollection at: index).		self assert: (iterated at: index) = (anOrderedCollection at: index) ]! !!GRSmallDictionaryTest methodsFor: 'tests-testing' stamp: 'jf 2/15/2010 16:05'!testIncludesKey	self deny: (collection includesKey: '1').	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	self assert: (collection includesKey: '1')! !!GRSmallDictionaryTest methodsFor: 'tests-testing' stamp: 'jf 2/15/2010 16:05'!testIsCollection	self assert: collection isCollection! !!GRSmallDictionaryTest methodsFor: 'tests-testing' stamp: 'jf 2/15/2010 16:05'!testIsEmpty	self assert: collection isEmpty.	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	self deny: collection isEmpty! !!GRSmallDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 22:06'!isKey: anObject equivalentTo: anotherObject	^ anObject = anotherObject! !!GRSmallDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 17:45'!newCollection	^ self collectionClass new! !!GRSmallDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 17:45'!collectionClass	^ GRSmallDictionary! !!GRSmallDictionaryTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 13:52'!allowsDuplicateKeys	^ false! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAddAndAssociations	| association |	association := collection add: '1' -> 'foo'.	self assert: association key = '1'.	self assert: association value = 'foo'.	self assertAssociations: (Array with: '1' -> 'foo').		association := collection add: '2' -> 'bar'.	self assert: association key = '2'.	self assert: association value = 'bar'.	self assertAssociations: (Array with: '1' -> 'foo' with: '2' -> 'bar').		association := collection add: '1' -> 'baz'.	self assert: association key = '1'.	self assert: association value = 'baz'.	self assertAssociations:		(self allowsDuplicateKeys			ifFalse: [ Array with: '1' -> 'baz' with: '2' -> 'bar' ]			ifTrue: [ Array with: '1' -> 'foo' with: '2' -> 'bar' with: '1' -> 'baz' ])! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'pmm 9/1/2012 15:33'!testSize	self assert: collection size = 0.	collection add: '1' -> 'foo'.	self assert: collection size = 1.	collection add: '2' -> 'bar'.	self assert: collection size = 2.	collection add: '1' -> 'baz'.	self assert: collection size = 		(self allowsDuplicateKeys ifTrue: [ 3 ] ifFalse: [ 2 ])! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAtIfAbsent	self assert: (collection at: '1' ifAbsent: [ 'foo' ]) = 'foo'.	collection add: '1' -> 'bar'.	collection add: '1' -> 'baz'.	self assert: (collection at: '1' ifAbsent: [ 'foo' ]) = 		(self allowsDuplicateKeys ifTrue: [ 'bar' ] ifFalse: [ 'baz' ])! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 22:58'!testAddAll	| dict result |	dict := (Dictionary new at: '1' put: 'foo'; yourself).	result := collection addAll: dict.	self assert: result == dict.	self assertAssociations: (Array with: '1' -> 'foo').		dict := (GROrderedMultiMap new at: '1' put: 'foo'; at: '1' add: 'bar'; yourself).	collection := self newCollection.	result := collection addAll: dict.	self assert: result == dict.	self assertAssociations:		(self allowsDuplicateKeys			ifFalse: [ Array with: '1' -> 'bar' ]			ifTrue: [ Array with: '1' -> 'foo' with: '1' -> 'bar' ])! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAtIfAbsentPut	self assert: (collection at: '1' ifAbsentPut: [ 'foo' ]) = 'foo'.	self assertAssociations: (Array with: '1' -> 'foo').	self assert: (collection at: '1' ifAbsentPut: [ 'bar' ]) = 'foo'.	self assertAssociations: (Array with: '1' -> 'foo')! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'pmm 9/1/2012 15:33'!testAtPut	collection at: '1' put: 'foo'.	collection at: '2' put: 'bar'.	self assertAssociations: (Array with: '1' -> 'foo' with: '2' -> 'bar').	collection at: '1' put: 'baz'.	self assertAssociations: (Array with: '1' -> 'baz' with: '2' -> 'bar')! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAtIfPresent	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	self assert: (collection at: '1' ifPresent: [ :v | v , 'baz' ]) =		(self allowsDuplicateKeys ifTrue: [ 'foobaz' ] ifFalse: [ 'barbaz' ]).	self assert: (collection at: '2' ifPresent: [ :v | v , 'baz' ]) isNil! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAt	self should: [ collection at: '1' ] raise: Error.	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	self assert: (collection at: '1') =		(self allowsDuplicateKeys ifTrue: [ 'foo' ] ifFalse: [ 'bar' ])! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'pmm 9/1/2012 15:33'!testRemoveKeyIfAbsent	self assert: (collection removeKey: '1' ifAbsent: [ 'absent' ]) = 'absent'.	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	collection add: '2' -> 'baz'.	self assert: (collection removeKey: '1' ifAbsent: [ 'absent' ]) =		(self allowsDuplicateKeys ifTrue: [ #('foo' 'bar') ] ifFalse: [ 'bar' ]).	self assertAssociations: (Array with: '2' -> 'baz').	self assert: (collection removeKey: '2' ifAbsent: [ 'absent' ]) =		(self allowsDuplicateKeys ifTrue: [ #('baz') ] ifFalse: [ 'baz' ]).	self assertAssociations: #()! !!GRSmallDictionaryTest methodsFor: 'tests-accessing' stamp: 'pmm 9/1/2012 15:33'!testRemoveKey	self should: [ collection removeKey: '1' ] raise: Error.	collection add: '1' -> 'foo'.	collection add: '1' -> 'bar'.	collection add: '2' -> 'baz'.	self assert: (collection removeKey: '1') =		(self allowsDuplicateKeys ifTrue: [ #('foo' 'bar') ] ifFalse: [ 'bar' ]).	self assertAssociations: (Array with: '2' -> 'baz').	self assert: (collection removeKey: '2') =		(self allowsDuplicateKeys ifTrue: [ #('baz') ] ifFalse: [ 'baz' ]).	self assertAssociations: #()! !!GRSmallDictionaryTest methodsFor: 'running' stamp: 'jf 2/15/2010 16:05'!setUp	super setUp.	collection := self newCollection! !GRSmallDictionaryTest subclass: #GROrderedMultiMapTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GROrderedMultiMapTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 17:46'!collectionClass	^ GROrderedMultiMap! !!GROrderedMultiMapTest methodsFor: 'configuration' stamp: 'jf 2/15/2010 13:53'!allowsDuplicateKeys	^ true! !!GROrderedMultiMapTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAtAdd	collection at: '1' add: 'foo'.	collection at: '1' add: 'bar'.	self assertAssociations: (Array with: '1' -> 'foo' with: '1' -> 'bar')! !!GROrderedMultiMapTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAllAt	self assert: (collection allAt: '1') = #().	collection at: '1' add: 'foo'.	collection at: '1' add: 'bar'.	self assert: (collection allAt: '1') = #( 'foo' 'bar' )! !!GROrderedMultiMapTest methodsFor: 'tests-accessing' stamp: 'jf 2/15/2010 16:05'!testAllAtIfAbsent	self assert: (collection allAt: '1' ifAbsent: [ 'absent' ]) = 'absent'.	collection at: '1' add: 'foo'.	collection at: '1' add: 'bar'.	self assert: (collection allAt: '1' ifAbsent: [ 'absent' ]) = #( 'foo' 'bar' )! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!GROrderedMultiMapTest class	instanceVariableNames: ''!!GROrderedMultiMapTest class methodsFor: 'testing' stamp: 'jf 2/15/2010 13:29'!shouldInheritSelectors	^ true! !GRAbstractSequenceableCollectionTest subclass: #GRSortedCollectionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRSortedCollectionTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 14:30'!collectionClass	^ SortedCollection! !!GRSortedCollectionTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 14:29'!allowsDuplicateValues	^ true! !!GRSortedCollectionTest methodsFor: 'testing-ansi' stamp: 'jok 3/25/2010 14:26'!isSequenced	^ false! !!GRSortedCollectionTest methodsFor: 'testing-ansi' stamp: 'jok 3/22/2010 14:31'!isExtensible	^ true! !!GRSortedCollectionTest methodsFor: 'testing-ansi' stamp: 'jok 3/22/2010 14:34'!isInitializable	^ true! !!GRSortedCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:05'!isUnique	^ false! !!GRSortedCollectionTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:23'!isHomogeneous	^ true! !GRAbstractSequenceableCollectionTest subclass: #GRStringTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRStringTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:24'!testSubStrings	"#subStrings: is defined by ANSI 5.7.10.15:	Answer an array containing the substrings in the receiver separated by the elements of separators."	| mimeType tokens |	mimeType := 'application/xhtml+xml'.	tokens := mimeType subStrings: '/'.	self assert: tokens size = 2.	self assert: tokens first = 'application'.	self assert: tokens second = 'xhtml+xml'.		"ANSI is a bit unclear on how multiple sequential delimiters should be treated.	Make sure behaviour is consistent for several delimiters in a row (taken from	Squeak's behaviour)"	tokens := 'abc,.def.ghi' subStrings: '.,'.	self assert: tokens size = 3.	self assert: tokens first = 'abc'.	self assert: tokens second = 'def'.	self assert: tokens third = 'ghi'.	"also ensure behavior consistent for several delimiters in a row at beginning and end of string...for completeness"	tokens := ',.abc,.def.ghi.,' subStrings: '.,'.	self assert: tokens size = 3.	self assert: tokens first = 'abc'.	self assert: tokens second = 'def'.	self assert: tokens third = 'ghi'! !!GRStringTest methodsFor: 'tests-trim' stamp: 'jf 9/25/2009 16:46'!testTrimBoth	self assert: '' trimBoth = ''.	self assert: ' ' trimBoth = ''.	self assert: '	' trimBoth = ''.	self assert: 'foo' trimBoth = 'foo'.	self assert: ' foo ' trimBoth = 'foo'.	self assert: '  foo  ' trimBoth = 'foo'.	self assert: ((String with: Character cr), '   foo  ') trimBoth = 'foo'.		self assert: ('aabbaa' trimBoth: [ :each | each = $a ]) = 'bb'.	self assert: ('bbaabb' trimBoth: [ :each | each = $a ]) = 'bbaabb'! !!GRStringTest methodsFor: 'tests-trim' stamp: 'lr 2/7/2008 09:35'!testTrimRight	self assert: '' trimRight = ''.	self assert: ' ' trimRight = ''.	self assert: '	' trimRight = ''.	self assert: 'foo' trimRight = 'foo'.	self assert: ' foo ' trimRight = ' foo'.	self assert: '  foo  ' trimRight = '  foo'.		self assert: ('aabbaa' trimRight: [ :each | each = $a ]) = 'aabb'.	self assert: ('bbaabb' trimRight: [ :each | each = $a ]) = 'bbaabb'! !!GRStringTest methodsFor: 'tests-trim' stamp: 'lr 2/7/2008 09:34'!testTrimLeft	self assert: '' trimLeft = ''.	self assert: ' ' trimLeft = ''.	self assert: '	' trimLeft = ''.	self assert: 'foo' trimLeft = 'foo'.	self assert: ' foo ' trimLeft = 'foo '.	self assert: '  foo  ' trimLeft = 'foo  '.		self assert: ('aabbaa' trimLeft: [ :each | each = $a ]) = 'bbaa'.	self assert: ('bbaabb' trimLeft: [ :each | each = $a ]) = 'bbaabb'! !!GRStringTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 04:04'!isSequenced	^ true! !!GRStringTest methodsFor: 'testing-ansi' stamp: 'jf 2/6/2010 03:35'!isExtensible	^ false! !!GRStringTest methodsFor: 'testing-ansi' stamp: 'jf 2/9/2010 11:28'!isInitializable	^ true! !!GRStringTest methodsFor: 'tests-truncate' stamp: 'lr 2/7/2008 09:32'!testTruncateEmpty	self assert: '' truncate = ''! !!GRStringTest methodsFor: 'tests-truncate' stamp: 'lr 2/7/2008 09:32'!testTruncate	self assert: ('abc' truncate) = 'abc'.	self assert: ('abc' truncate: 3) = 'abc'.	self assert: ('abc' truncate: 2) = 'ab...'.		self assert: ('abc' truncate: 1 ellipsis: '') = 'a'.	self assert: ('abc' truncate: 0 ellipsis: 'none') = 'none'! !!GRStringTest methodsFor: 'tests-excerpt' stamp: 'lr 2/7/2008 09:31'!testExcerptEmpty	self assert: ('' excerpt: '') isNil.	self assert: ('' excerpt: 'x') isNil.	self assert: ('x' excerpt: '') isNil! !!GRStringTest methodsFor: 'tests-excerpt' stamp: 'lr 2/7/2008 09:31'!testExcerpt	self assert: ('abcde' excerpt: 'c' radius: 0) = '...c...'.	self assert: ('abcde' excerpt: 'c' radius: 1) = '...bcd...'.	self assert: ('abcde' excerpt: 'c' radius: 2) = 'abcde'.	self assert: ('abcde' excerpt: 'c' radius: 3) = 'abcde'.		self assert: ('abcde' excerpt: 'c' radius: 0 ellipsis: 'x') = 'xcx'.	self assert: ('abcde' excerpt: 'c' radius: 1 ellipsis: 'x') = 'xbcdx'.	self assert: ('abcde' excerpt: 'c' radius: 2 ellipsis: 'x') = 'abcde'! !!GRStringTest methodsFor: 'tests-excerpt' stamp: 'lr 2/7/2008 09:30'!testExcerptLeft	self assert: ('abcde' excerpt: 'd' radius: 0 ellipsis: 'x') = 'xdx'.	self assert: ('abcde' excerpt: 'd' radius: 1 ellipsis: 'x') = 'xcde'.	self assert: ('abcde' excerpt: 'd' radius: 2 ellipsis: 'x') = 'xbcde'.	self assert: ('abcde' excerpt: 'd' radius: 3 ellipsis: 'x') = 'abcde'! !!GRStringTest methodsFor: 'tests-excerpt' stamp: 'lr 2/7/2008 09:29'!testExcerptRight	self assert: ('abcde' excerpt: 'b' radius: 0 ellipsis: 'x') = 'xbx'.	self assert: ('abcde' excerpt: 'b' radius: 1 ellipsis: 'x') = 'abcx'.	self assert: ('abcde' excerpt: 'b' radius: 2 ellipsis: 'x') = 'abcdx'.	self assert: ('abcde' excerpt: 'b' radius: 3 ellipsis: 'x') = 'abcde'! !!GRStringTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 01:50'!collectionClass	^ String! !!GRStringTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:44'!duplicateElement	^ $b! !!GRStringTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:44'!includedElement	^ $d! !!GRStringTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 02:20'!excludedElement	^ $Q! !!GRStringTest methodsFor: 'configuration' stamp: 'jf 2/6/2010 04:22'!allowsDuplicateValues	^ true! !!GRStringTest methodsFor: 'configuration' stamp: 'jok 2/9/2010 13:19'!arbitraryCollection	^ 'fadbbc' copy   "String literals are immutable"! !!GRStringTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:14'!isUnique	^ false! !!GRStringTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:24'!isHomogeneous	^ true! !!GRStringTest methodsFor: 'tests-converting' stamp: 'pmm 9/1/2012 15:24'!testCapitalized	self assert: 'capitalized' capitalized = 'Capitalized'.	self assert: 'Capitalized' capitalized = 'Capitalized'.	self assert: 'CAPITALIZED' capitalized = 'CAPITALIZED'.	self assert: #'capitalized' capitalized = #'Capitalized'.	self assert: #'Capitalized' capitalized = #'Capitalized'.	self assert: #'CAPITALIZED' capitalized = #'CAPITALIZED'! !!GRStringTest methodsFor: 'tests-converting' stamp: 'jf 9/25/2009 16:50'!testAsUppercase	self assert: 'abc' asUppercase = 'ABC'.	self assert: 'ABC' asUppercase = 'ABC'! !!GRStringTest methodsFor: 'tests-converting' stamp: 'jf 9/25/2009 16:50'!testCapitalizedUmlauts	self assert: 'äöü' capitalized = 'Äöü'.	self assert: 'Äöü' capitalized = 'Äöü'.	self assert: 'ÄÖÜ' capitalized = 'ÄÖÜ'.	self assert: #'äöü' capitalized = #'Äöü'.	self assert: #'Äöü' capitalized = #'Äöü'.	self assert: #'ÄÖÜ' capitalized = #'ÄÖÜ'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'lr 2/7/2008 10:21'!testInflectorAssimilated	self assert: 'vertice' pluralize = 'vertices'.	self assert: 'index' pluralize = 'indices'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'pmm 9/1/2012 15:24'!testInflectorYyyySuffixes	self assert: 'story' pluralize = 'stories'.	self assert: 'lady' pluralize = 'ladies'.	self assert: 'stay' pluralize = 'stays'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'lr 2/7/2008 09:11'!testInflectorFfffSuffixes	self assert: 'life' pluralize = 'lives'.	self assert: 'wolf' pluralize = 'wolves'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'mlucas-smith 6/3/2009 22:33'!testInflectorNotInflecting	self assert: 'fish' pluralize = 'fish'.	self assert: 'travois' pluralize = 'travois'.	self assert: 'chassis' pluralize = 'chassis'.	self assert: 'nationalities' pluralize = 'nationalities'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'lr 2/7/2008 09:11'!testInflectorTsssSuffixes	self assert: 'church' pluralize = 'churches'.	self assert: 'class' pluralize = 'classes'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'lr 2/7/2008 10:21'!testInflectorIrregular	self assert: 'genie' pluralize = 'genies'.	self assert: 'ox' pluralize = 'oxen'.	self assert: 'cow' pluralize = 'kine'.	self assert: 'child' pluralize = 'children'.	self assert: 'woman' pluralize = 'women'! !!GRStringTest methodsFor: 'tests-pluralize' stamp: 'lr 2/7/2008 09:11'!testInflectorCommonSuffixes	self assert: 'mouse' pluralize = 'mice'.	self assert: 'synopse' pluralize = 'synopses'.	self assert: 'man' pluralize = 'men'! !GRAbstractSequenceableCollectionTest subclass: #GRSymbolTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRSymbolTest methodsFor: 'testing' stamp: 'jok 3/26/2010 12:38'!isUnique	^ true! !!GRSymbolTest methodsFor: 'testing' stamp: 'jok 3/29/2010 13:24'!isHomogeneous	^ true! !!GRSymbolTest methodsFor: 'testing-ansi' stamp: 'jok 3/25/2010 14:27'!isSequenced	^ false! !!GRSymbolTest methodsFor: 'testing-ansi' stamp: 'jok 3/22/2010 14:38'!isExtensible	^ false! !!GRSymbolTest methodsFor: 'testing-ansi' stamp: 'jok 3/25/2010 14:21'!isInitializable	^ false! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/29/2010 14:27'!emptyCollection	^ #''! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 14:15'!collectionClass	^ Symbol! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/29/2010 12:21'!duplicateElement	^ $b! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 14:59'!includedElement	^ $d! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/26/2010 16:41'!allowsDuplicateValues	^ true! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 15:00'!excludedElement	^ $Q! !!GRSymbolTest methodsFor: 'configuration' stamp: 'jok 3/22/2010 14:37'!arbitraryCollection	^ #'fadbbc'! !TestCase subclass: #GRUtf8CodecTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRUtf8CodecTest methodsFor: 'tests' stamp: 'pmm 11/10/2010 06:59'!testCodecUtf8Bom	#('UTF-8' 'utf-8') do: [ :codecName |		| codec bom |		codec := GRCodec forEncoding: codecName.		bom := self asString: #(239 187 191).		self assert: (codec decode: bom , self utf8String) greaseString = self decodedString greaseString.		self assert: (codec url decode: bom , self utf8String) greaseString = self decodedString greaseString ]! !!GRUtf8CodecTest methodsFor: 'tests' stamp: 'pmm 4/11/2010 19:47'!testCodecUtf8ShortestForm	"Non shortest form characters should be rejected	See Corrigendum #1: UTF-8 Shortest Form http://www.unicode.org/versions/corrigendum1.html"	#('UTF-8' 'utf-8') do: [ :codecName |		| codec abc |		codec := GRCodec forEncoding: codecName.		abc := self asString: #(193 129 193 130 193 131 ).		self			should: [ self deny: (codec decode: abc) = 'ABC' ]			raise: Error ]! !!GRUtf8CodecTest methodsFor: 'tests' stamp: 'pmm 10/25/2010 18:50'!testCodecUtf8	#('UTF-8' 'utf-8') do: [ :codecName |		| codec |		codec := GRCodec forEncoding: codecName.		self assert: codec name asLowercase = codecName asLowercase.		self assert: codec url name asLowercase = codecName asLowercase.		self assert: (codec encode: self decodedString) greaseString = self utf8String greaseString.		self assert: (codec url encode: self decodedString) greaseString = self utf8String greaseString.		self assert: (codec decode: self utf8String) = self decodedString.		self assert: (codec url decode: self utf8String) = self decodedString ]! !!GRUtf8CodecTest methodsFor: 'tests' stamp: 'pmm 11/17/2010 22:11'!testCodecUtf8BorderLineString	#('UTF-8' 'utf-8') do: [ :codecName |		| codec writeStream |		codec := GRCodec forEncoding: codecName.		writeStream := codec encoderFor: GRPlatform current readWriteCharacterStream.		writeStream nextPut: (Character codePoint: 0).		writeStream nextPut: (Character codePoint: 255).		writeStream nextPut: (Character codePoint: 256).		self assert: writeStream contents = (String			with: (Character codePoint: 16r00) "character 0" 			with: (Character codePoint: 16rC3) with: (Character codePoint: 16rBF) "character 255" 			with: (Character codePoint: 16rC4) with: (Character codePoint: 16r80)) "character 256"  ]! !!GRUtf8CodecTest methodsFor: 'tests' stamp: 'pmm 2/17/2010 20:07'!testNext	| stream |	stream := (GRCodec forEncoding: 'utf8')		encoderFor: self seasideByteArray readStream.	self assert: stream next = $S.	self assert: (stream next: 1) = 'e'! !!GRUtf8CodecTest methodsFor: 'private' stamp: 'lr 7/25/2011 19:52'!asString: aCollectionOfIntegers	^ String streamContents: [ :stream |		aCollectionOfIntegers do: [ :each |			stream nextPut: (Character codePoint: each) ] ]! !!GRUtf8CodecTest methodsFor: 'private' stamp: 'pmm 2/17/2010 20:02'!seasideByteArray	^ #(83 101 97 115 105 100 101) "Seaside" asByteArray! !!GRUtf8CodecTest methodsFor: 'accessing' stamp: 'PaoloBonzini 4/7/2010 09:30'!decodedString	^ 'Übèrstrîñgé'! !!GRUtf8CodecTest methodsFor: 'accessing' stamp: 'dkh 11/13/2009 15:27'!utf8String	^ self asString: #(195 156 98 195 168 114 115 116 114 195 174 195 177 103 195 169)! !TestCase subclass: #GRVersionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Grease-Tests-Core'!!GRVersionTest methodsFor: 'private' stamp: 'jf 2/8/2010 23:31'!buildVersion: anArray	^ (GRVersion		major: (anArray at: 1 ifAbsent: [ nil ])		minor: (anArray at: 2 ifAbsent: [ nil ])		revision: (anArray at: 3 ifAbsent: [ nil ]))			stage: (anArray at: 4 ifAbsent: [ nil ]) number: (anArray at: 5 ifAbsent: [ nil ]);			yourself! !!GRVersionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:55'!testComparison	self assert: #(1) sortsBefore: #(2).	self assert: #(2) sortsBefore: #(10).	self assert: #(1) sortsBefore: #(1 1).	self assert: #(1 nil nil #alpha) sortsBefore: #(1).	self assert: #(1 nil nil #alpha) sortsBefore: #(1 0).	self assert: #(1 nil nil #alpha) sortsBefore: #(1 0 0).	self assert: #(1 0) sortsBefore: #(2).	self assert: #(1 0) sortsBefore: #(2 0).	self assert: #(1 0) sortsBefore: #(1 1).	self assert: #(1 2) sortsBefore: #(1 10).	self assert: #(1 0 nil #alpha) sortsBefore: #(1 0).	self assert: #(1 0 nil #alpha) sortsBefore: #(1 0 0).	self assert: #(1 0 0) sortsBefore: #(2).	self assert: #(1 0 0) sortsBefore: #(1 1).	self assert: #(1 0 1) sortsBefore: #(1 1).	self assert: #(1 0 1 #alpha) sortsBefore: #(1 1).	self assert: #(1 1 0 #alpha) sortsBefore: #(1 1).	self assert: #(1 1 0 #alpha 2) sortsBefore: #(1 1).	self assert: #(1 1 0 #beta) sortsBefore: #(1 1).	self assert: #(1 1 0 #beta 2) sortsBefore: #(1 1).	self assert: #(1 nil nil #alpha) sortsBefore: #(1 nil nil #alpha 2).	self assert: #(1 nil nil #beta) sortsBefore: #(1 nil nil #beta 2).	self assert: #(1 0 nil #alpha) sortsBefore: #(1 0 nil #alpha 2).	self assert: #(1 0 nil #beta) sortsBefore: #(1 0 nil #beta 2).	self assert: #(1 0 0 #alpha) sortsBefore: #(1 0 0 #alpha 2).	self assert: #(1 0 0 #beta) sortsBefore: #(1 0 0 #beta 2)! !!GRVersionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:50'!testStringConversion	self assert: (GRVersion major: 1 minor: 2 revision: 3) greaseString = '1.2.3'.	self assert: (GRVersion major: 11 minor: 12 revision: 13) greaseString = '11.12.13'.	self assert: (GRVersion major: 1 minor: 2) greaseString = '1.2'.	self assert: (GRVersion major: 1 minor: 2 revision: 0) greaseString = '1.2.0'.	self assert: (GRVersion major: 1) greaseString = '1.0'.	self assert: ((GRVersion major: 1 minor: 2 revision: 3) beAlpha) greaseString = '1.2.3alpha'.	self assert: ((GRVersion major: 1 minor: 2 revision: 3) beAlpha: 1) greaseString = '1.2.3alpha1'.	self assert: ((GRVersion major: 1 minor: 2 revision: 3) beBeta) greaseString = '1.2.3beta'.	self assert: ((GRVersion major: 1 minor: 2 revision: 3) beBeta: 1) greaseString = '1.2.3beta1'! !!GRVersionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:50'!testConvenience	| version |	version := GRVersion major: 1 minor: 2 revision: 3.	self assert: version stage isNil.	self assert: version stageNumber isNil.	self assert: version isFinal.	self deny: version isAlpha.	self deny: version isBeta.	version beAlpha.	self assert: version stage = #alpha.	self assert: version stageNumber isNil.	self assert: version isAlpha.	self deny: version isBeta.	self deny: version isFinal.	version beBeta.	self assert: version stage = #beta.	self assert: version stageNumber isNil.	self assert: version isBeta.	self deny: version isAlpha.	self deny: version isFinal.	version beReleaseCandidate.	self assert: version stage = #rc.	self assert: version stageNumber isNil.	self assert: version isReleaseCandidate.	version beReleaseCandidate: 1.	self assert: version stage = #rc.	self assert: version stageNumber = 1.	self assert: version isReleaseCandidate.	version beAlpha: 1.	self assert: version stage = #alpha.	self assert: version stageNumber = 1.	self assert: version isAlpha.	self deny: version isBeta.	self deny: version isFinal.	version beBeta: 1.	self assert: version stage = #beta.	self assert: version stageNumber = 1.	self assert: version isBeta.	self deny: version isAlpha.	self deny: version isFinal.	version beFinal.	self assert: version stage isNil.	self assert: version stageNumber isNil.	self assert: version isFinal.	self deny: version isAlpha.	self deny: version isBeta! !!GRVersionTest methodsFor: 'tests' stamp: 'pmm 9/1/2012 15:54'!testEquality	self assert: #(1) equals: #(1).	self assert: #(1) equals: #(1 0).	self assert: #(1) equals: #(1 0 0).	self assert: #(1 0) equals: #(1 0).	self assert: #(1 0) equals: #(1 0 0).	self assert: #(1 0 0) equals: #(1 0 0).	self assert: #(1 0 0 #alpha) equals: #(1 0 0 #alpha 1).	self assert: #(1 0 0 #beta) equals: #(1 0 0 #beta 1)! !!GRVersionTest methodsFor: 'asserting' stamp: 'pmm 9/1/2012 15:55'!assert: aVersionArray sortsBefore: bVersionArray	| a b |	a := self buildVersion: aVersionArray.	b := self buildVersion: bVersionArray.	self assert: a < b.	self assert: a <= b.	self deny: b < a.	self deny: b <= a.	self assert: b > a.	self assert: b >= a.	self deny: a > b.	self deny: a >= b.	self deny: a = b! !!GRVersionTest methodsFor: 'asserting' stamp: 'pmm 9/1/2012 15:54'!assert: aVersionArray equals: bVersionArray	| a b |	a := self buildVersion: aVersionArray.	b := self buildVersion: bVersionArray.	self deny: a < b.	self assert: a <= b.	self deny: b < a.	self assert: b <= a.	self deny: b > a.	self assert: b >= a.	self deny: a > b.	self assert: a >= b.	self assert: a = b! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 12 April 2018 at 7:26:48.057133 pm'!!GRPackage class methodsFor: '*grease-tests-core' stamp: 'pmm 9/12/2013 16:00'!greaseTestsCore	^ self new		name: 'Grease-Tests-Core';		description: 'Unit tests for the package Grease-Core.';		addDependency: 'Grease-Core';		url: #greaseUrl;		yourself! !